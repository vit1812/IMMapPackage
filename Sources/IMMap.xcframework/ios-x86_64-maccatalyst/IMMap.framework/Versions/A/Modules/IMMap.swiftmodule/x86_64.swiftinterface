// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
// swift-module-flags: -target x86_64-apple-ios13.1-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name IMMap
import AVKit
import Accelerate
import CommonCrypto
import CoreData
import CoreGraphics
import CoreImage
import CoreLocation
import Darwin
import Dispatch
import Dispatch/*.DispatchTimeInterval*/
import Foundation
import Foundation/*.BlockOperation*/
import Foundation/*.Data*/
import Foundation/*.Date*/
import Foundation/*.DateFormatter*/
import Foundation/*.HTTPURLResponse*/
import Foundation/*.IndexPath*/
import Foundation/*.JSONSerialization*/
import Foundation/*.NSCopying*/
import Foundation/*.NSError*/
import Foundation/*.NSLock*/
import Foundation/*.NSNull*/
import Foundation/*.NSNumber*/
import Foundation/*.NSObject*/
import Foundation/*.NSRecursiveLock*/
import Foundation/*.NSURLErrorCancelled*/
import Foundation/*.NSURLErrorDomain*/
import Foundation/*.NSValue*/
import Foundation/*.Notification*/
import Foundation/*.NotificationCenter*/
import Foundation/*.Operation*/
import Foundation/*.OperationQueue*/
import Foundation/*.Thread*/
import Foundation/*.TimeInterval*/
import Foundation/*.URL*/
import Foundation/*.URLRequest*/
import Foundation/*.URLResponse*/
import Foundation/*.URLSession*/
import Foundation/*.arc4random*/
import Foundation/*.objc_getAssociatedObject*/
import Foundation/*.objc_setAssociatedObject*/
@_exported import IMMap
import ImageIO
import MapKit
import MobileCoreServices
import Foundation.NSObject
import QuartzCore
import SafariServices
import Swift
import SystemConfiguration
@_exported import UIKit
import WebKit
public typealias Signal<Element> = IMMap.SharedSequence<IMMap.SignalSharingStrategy, Element>
public struct SignalSharingStrategy : IMMap.SharingStrategyProtocol {
  public static var scheduler: IMMap.SchedulerType {
    get
  }
  public static func share<Element>(_ source: IMMap.Observable<Element>) -> IMMap.Observable<Element>
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == IMMap.SignalSharingStrategy {
  public func asSignal() -> IMMap.Signal<Self.Element>
}
extension EKAttributes {
  public struct UserInteraction {
    public typealias Action = () -> ()
    public enum Default {
      case absorbTouches
      case delayExit(by: Foundation.TimeInterval)
      case dismissEntry
      case forward
    }
    public var defaultAction: IMMap.EKAttributes.UserInteraction.Default
    public var customTapActions: [IMMap.EKAttributes.UserInteraction.Action]
    public init(defaultAction: IMMap.EKAttributes.UserInteraction.Default = .absorbTouches, customTapActions: [IMMap.EKAttributes.UserInteraction.Action] = [])
    public static var dismiss: IMMap.EKAttributes.UserInteraction {
      get
    }
    public static var forward: IMMap.EKAttributes.UserInteraction {
      get
    }
    public static var absorbTouches: IMMap.EKAttributes.UserInteraction {
      get
    }
    public static func delayExit(by delay: Foundation.TimeInterval) -> IMMap.EKAttributes.UserInteraction
  }
}
extension ObservableType {
  public static func empty() -> IMMap.Observable<Self.Element>
}
@objc final public class EKButtonBarView : UIKit.UIView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public init(with buttonBarContent: IMMap.EKProperty.ButtonBarContent)
  @objc override final public func layoutSubviews()
  final public func expand()
  final public func compress()
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension Reactive where Base : UIKit.UITabBarItem {
  public var badgeValue: IMMap.Binder<Swift.String?> {
    get
  }
}
public protocol ObserverType {
  associatedtype Element
  @available(*, deprecated, renamed: "Element")
  typealias E = Self.Element
  func on(_ event: IMMap.Event<Self.Element>)
}
extension ObserverType {
  public func onNext(_ element: Self.Element)
  public func onCompleted()
  public func onError(_ error: Swift.Error)
}
@objc open class TaskDelegate : ObjectiveC.NSObject {
  final public let queue: Foundation.OperationQueue
  public var data: Foundation.Data? {
    get
  }
  public var error: Swift.Error?
  @objc override dynamic public init()
  @objc deinit
}
extension EKAttributes {
  public enum NotificationHapticFeedback {
    case success
    case warning
    case error
    case none
    public static func == (a: IMMap.EKAttributes.NotificationHapticFeedback, b: IMMap.EKAttributes.NotificationHapticFeedback) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public struct FormatIndicatedCacheSerializer : IMMap.CacheSerializer {
  public static let png: IMMap.FormatIndicatedCacheSerializer
  public static let jpeg: IMMap.FormatIndicatedCacheSerializer
  public static func jpeg(compressionQuality: CoreGraphics.CGFloat) -> IMMap.FormatIndicatedCacheSerializer
  public static let gif: IMMap.FormatIndicatedCacheSerializer
  public func data(with image: IMMap.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public enum AFError : Swift.Error {
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case propertyListEncodingFailed(error: Swift.Error)
  }
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNil
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case propertyListSerializationFailed(error: Swift.Error)
  }
  case invalidURL(url: IMMap.URLConvertible)
  case parameterEncodingFailed(reason: IMMap.AFError.ParameterEncodingFailureReason)
  case multipartEncodingFailed(reason: IMMap.AFError.MultipartEncodingFailureReason)
  case responseValidationFailed(reason: IMMap.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: IMMap.AFError.ResponseSerializationFailureReason)
}
extension AFError {
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
}
extension AFError {
  public var urlConvertible: IMMap.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
}
extension AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ObservableType {
  public func bind(to relays: IMMap.PublishRelay<Self.Element>...) -> IMMap.Disposable
  public func bind(to relays: IMMap.PublishRelay<Self.Element?>...) -> IMMap.Disposable
  public func bind(to relays: IMMap.BehaviorRelay<Self.Element>...) -> IMMap.Disposable
  public func bind(to relays: IMMap.BehaviorRelay<Self.Element?>...) -> IMMap.Disposable
}
@available(iOS 10.0, tvOS 10.0, *)
extension UICollectionView : IMMap.HasPrefetchDataSource {
  public typealias PrefetchDataSource = UIKit.UICollectionViewDataSourcePrefetching
}
@available(iOS 10.0, tvOS 10.0, *)
open class RxCollectionViewDataSourcePrefetchingProxy : IMMap.DelegateProxy<UIKit.UICollectionView, UIKit.UICollectionViewDataSourcePrefetching>, IMMap.DelegateProxyType, UIKit.UICollectionViewDataSourcePrefetching {
  weak public var collectionView: UIKit.UICollectionView? {
    get
    }
  public init(collectionView: IMMap.RxCollectionViewDataSourcePrefetchingProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, prefetchItemsAt indexPaths: [Foundation.IndexPath])
  override open func setForwardToDelegate(_ forwardToDelegate: UIKit.UICollectionViewDataSourcePrefetching?, retainDelegate: Swift.Bool)
  @objc deinit
  override public init<Proxy>(parentObject: UIKit.UICollectionView, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UICollectionView, UIKit.UICollectionViewDataSourcePrefetching>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UICollectionViewDataSourcePrefetching, Proxy.ParentObject == UIKit.UICollectionView
}
final public class PublishSubject<Element> : IMMap.Observable<Element>, IMMap.SubjectType, IMMap.Cancelable, IMMap.ObserverType {
  public typealias SubjectObserverType = IMMap.PublishSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  override public init()
  final public func on(_ event: IMMap.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where Element == Observer.Element, Observer : IMMap.ObserverType
  final public func asObserver() -> IMMap.PublishSubject<Element>
  final public func dispose()
  @objc deinit
  public typealias Observer = IMMap.PublishSubject<Element>
}
final public class ScheduledDisposable : IMMap.Cancelable {
  final public let scheduler: IMMap.ImmediateSchedulerType
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(scheduler: IMMap.ImmediateSchedulerType, disposable: IMMap.Disposable)
  final public func dispose()
  @objc deinit
}
extension ObservableType {
  public static func error(_ error: Swift.Error) -> IMMap.Observable<Self.Element>
}
@objc public class EKProcessingNoteMessageView : IMMap.EKAccessoryNoteMessageView {
  public var isProcessing: Swift.Bool {
    get
    set
  }
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public init(with content: IMMap.EKProperty.LabelContent, activityIndicator: UIKit.UIActivityIndicatorView.Style)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension UITableView : IMMap.HasDataSource {
  public typealias DataSource = UIKit.UITableViewDataSource
}
open class RxTableViewDataSourceProxy : IMMap.DelegateProxy<UIKit.UITableView, UIKit.UITableViewDataSource>, IMMap.DelegateProxyType, UIKit.UITableViewDataSource {
  weak public var tableView: UIKit.UITableView? {
    get
    }
  public init(tableView: UIKit.UITableView)
  public static func registerKnownImplementations()
  @objc public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  override open func setForwardToDelegate(_ forwardToDelegate: UIKit.UITableViewDataSource?, retainDelegate: Swift.Bool)
  override public init<Proxy>(parentObject: UIKit.UITableView, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UITableView, UIKit.UITableViewDataSource>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UITableViewDataSource, Proxy.ParentObject == UIKit.UITableView
  @objc deinit
}
public protocol KVORepresentable {
  associatedtype KVOType
  init?(KVOValue: Self.KVOType)
}
extension ObservableType {
  public static func just(_ element: Self.Element) -> IMMap.Observable<Self.Element>
  public static func just(_ element: Self.Element, scheduler: IMMap.ImmediateSchedulerType) -> IMMap.Observable<Self.Element>
}
public typealias Driver<Element> = IMMap.SharedSequence<IMMap.DriverSharingStrategy, Element>
public struct DriverSharingStrategy : IMMap.SharingStrategyProtocol {
  public static var scheduler: IMMap.SchedulerType {
    get
  }
  public static func share<Element>(_ source: IMMap.Observable<Element>) -> IMMap.Observable<Element>
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == IMMap.DriverSharingStrategy {
  public func asDriver() -> IMMap.Driver<Self.Element>
}
public struct EKAttributes {
  public var name: Swift.String?
  public var windowLevel: IMMap.EKAttributes.WindowLevel
  public var position: IMMap.EKAttributes.Position
  public var precedence: IMMap.EKAttributes.Precedence
  public var displayDuration: IMMap.EKAttributes.DisplayDuration
  public var positionConstraints: IMMap.EKAttributes.PositionConstraints
  public var screenInteraction: IMMap.EKAttributes.UserInteraction
  public var entryInteraction: IMMap.EKAttributes.UserInteraction
  public var scroll: IMMap.EKAttributes.Scroll
  public var hapticFeedbackType: IMMap.EKAttributes.NotificationHapticFeedback
  public var lifecycleEvents: IMMap.EKAttributes.LifecycleEvents
  public var displayMode: IMMap.EKAttributes.DisplayMode
  public var entryBackground: IMMap.EKAttributes.BackgroundStyle
  public var screenBackground: IMMap.EKAttributes.BackgroundStyle
  public var shadow: IMMap.EKAttributes.Shadow
  public var roundCorners: IMMap.EKAttributes.RoundCorners
  public var border: IMMap.EKAttributes.Border
  public var statusBar: IMMap.EKAttributes.StatusBar
  public var entranceAnimation: IMMap.EKAttributes.Animation
  public var exitAnimation: IMMap.EKAttributes.Animation
  public var popBehavior: IMMap.EKAttributes.PopBehavior {
    get
    set
  }
  public init()
}
extension UINavigationController : IMMap.HasDelegate {
  public typealias Delegate = UIKit.UINavigationControllerDelegate
}
open class RxNavigationControllerDelegateProxy : IMMap.DelegateProxy<UIKit.UINavigationController, UIKit.UINavigationControllerDelegate>, IMMap.DelegateProxyType, UIKit.UINavigationControllerDelegate {
  weak public var navigationController: UIKit.UINavigationController? {
    get
    }
  public init(navigationController: IMMap.RxNavigationControllerDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  override public init<Proxy>(parentObject: UIKit.UINavigationController, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UINavigationController, UIKit.UINavigationControllerDelegate>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UINavigationControllerDelegate, Proxy.ParentObject == UIKit.UINavigationController
  @objc deinit
}
@objc public class EKXStatusBarMessageView : UIKit.UIView {
  public init(leading: IMMap.EKProperty.LabelContent, trailing: IMMap.EKProperty.LabelContent)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension NibResourceType {
  public func instantiate(withOwner ownerOrNil: Any?, options optionsOrNil: [UIKit.UINib.OptionsKey : Any]? = [:]) -> [Any]
}
@objc final public class EKAlertMessageView : IMMap.EKSimpleMessageView {
  public init(with message: IMMap.EKAlertMessage)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public protocol ImageResourceType {
  var bundle: Foundation.Bundle { get }
  var name: Swift.String { get }
}
public struct RSwiftImageResource : IMMap.ImageResourceType {
  public let bundle: Foundation.Bundle
  public let name: Swift.String
  public init(bundle: Foundation.Bundle, name: Swift.String)
}
public protocol SeguePerformerType {
  func performSegue(withIdentifier identifier: Swift.String, sender: Any?)
}
extension UIViewController : IMMap.SeguePerformerType {
}
extension SeguePerformerType {
  public func performSegue<Segue, Destination>(withIdentifier identifier: IMMap.StoryboardSegueIdentifier<Segue, Self, Destination>, sender: Any?)
}
extension StoryboardSegue where Source : UIKit.UIViewController {
  public func performSegue(sender: Any? = nil)
}
public struct EKNotificationMessage {
  public struct Insets {
    public var contentInsets: UIKit.UIEdgeInsets
    public var titleToDescription: CoreGraphics.CGFloat
    public static var `default`: IMMap.EKNotificationMessage.Insets
  }
  public let simpleMessage: IMMap.EKSimpleMessage
  public let auxiliary: IMMap.EKProperty.LabelContent?
  public let insets: IMMap.EKNotificationMessage.Insets
  public init(simpleMessage: IMMap.EKSimpleMessage, auxiliary: IMMap.EKProperty.LabelContent? = nil, insets: IMMap.EKNotificationMessage.Insets = .default)
}
public protocol SubjectType : IMMap.ObservableType {
  associatedtype Observer : IMMap.ObserverType
  @available(*, deprecated, renamed: "Observer")
  typealias SubjectObserverType = Self.Observer
  func asObserver() -> Self.Observer
}
extension UITabBar : IMMap.HasDelegate {
  public typealias Delegate = UIKit.UITabBarDelegate
}
open class RxTabBarDelegateProxy : IMMap.DelegateProxy<UIKit.UITabBar, UIKit.UITabBarDelegate>, IMMap.DelegateProxyType, UIKit.UITabBarDelegate {
  weak public var tabBar: UIKit.UITabBar? {
    get
    }
  public init(tabBar: IMMap.RxTabBarDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  open class func currentDelegate(for object: IMMap.RxTabBarDelegateProxy.ParentObject) -> UIKit.UITabBarDelegate?
  open class func setCurrentDelegate(_ delegate: UIKit.UITabBarDelegate?, to object: IMMap.RxTabBarDelegateProxy.ParentObject)
  override public init<Proxy>(parentObject: UIKit.UITabBar, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UITabBar, UIKit.UITabBarDelegate>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UITabBarDelegate, Proxy.ParentObject == UIKit.UITabBar
  @objc deinit
}
open class RxCollectionViewDelegateProxy : IMMap.RxScrollViewDelegateProxy, UIKit.UICollectionViewDelegate, UIKit.UICollectionViewDelegateFlowLayout {
  weak public var collectionView: UIKit.UICollectionView? {
    get
    }
  public init(collectionView: UIKit.UICollectionView)
  override public init(scrollView: IMMap.RxScrollViewDelegateProxy.ParentObject)
  @objc deinit
}
extension Reactive where Base : UIKit.UITextField {
  public var text: IMMap.ControlProperty<Swift.String?> {
    get
  }
  public var value: IMMap.ControlProperty<Swift.String?> {
    get
  }
  public var attributedText: IMMap.ControlProperty<Foundation.NSAttributedString?> {
    get
  }
  public var isSecureTextEntry: IMMap.Binder<Swift.Bool> {
    get
  }
}
public protocol ImageDownloadRedirectHandler {
  func handleHTTPRedirection(for task: IMMap.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct AnyRedirectHandler : IMMap.ImageDownloadRedirectHandler {
  public func handleHTTPRedirection(for task: IMMap.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public init(handle: @escaping (IMMap.SessionDataTask, Foundation.HTTPURLResponse, Foundation.URLRequest, (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: IMMap.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> IMMap.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : IMMap.KVORepresentable
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: IMMap.KeyValueObservingOptions = [.new, .initial]) -> IMMap.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : IMMap.KVORepresentable
}
public protocol Placeholder {
  func add(to imageView: IMMap.KFCrossPlatformImageView)
  func remove(from imageView: IMMap.KFCrossPlatformImageView)
}
extension UIImage : IMMap.Placeholder {
  public func add(to imageView: IMMap.KFCrossPlatformImageView)
  public func remove(from imageView: IMMap.KFCrossPlatformImageView)
}
extension Placeholder where Self : IMMap.KFCrossPlatformView {
  public func add(to imageView: IMMap.KFCrossPlatformImageView)
  public func remove(from imageView: IMMap.KFCrossPlatformImageView)
}
extension EKAttributes {
  public enum BackgroundStyle : Swift.Equatable {
    public struct BlurStyle : Swift.Equatable {
      public static var extra: IMMap.EKAttributes.BackgroundStyle.BlurStyle {
        get
      }
      public static var standard: IMMap.EKAttributes.BackgroundStyle.BlurStyle {
        get
      }
      @available(iOS 10.0, *)
      public static var prominent: IMMap.EKAttributes.BackgroundStyle.BlurStyle {
        get
      }
      public static var dark: IMMap.EKAttributes.BackgroundStyle.BlurStyle {
        get
      }
      public init(style: UIKit.UIBlurEffect.Style)
      public init(light: UIKit.UIBlurEffect.Style, dark: UIKit.UIBlurEffect.Style)
      public func blurStyle(for traits: UIKit.UITraitCollection, mode: IMMap.EKAttributes.DisplayMode) -> UIKit.UIBlurEffect.Style
      public func blurEffect(for traits: UIKit.UITraitCollection, mode: IMMap.EKAttributes.DisplayMode) -> UIKit.UIBlurEffect
      public static func == (a: IMMap.EKAttributes.BackgroundStyle.BlurStyle, b: IMMap.EKAttributes.BackgroundStyle.BlurStyle) -> Swift.Bool
    }
    public struct Gradient {
      public var colors: [IMMap.EKColor]
      public var startPoint: CoreGraphics.CGPoint
      public var endPoint: CoreGraphics.CGPoint
      public init(colors: [IMMap.EKColor], startPoint: CoreGraphics.CGPoint, endPoint: CoreGraphics.CGPoint)
    }
    case visualEffect(style: IMMap.EKAttributes.BackgroundStyle.BlurStyle)
    case color(color: IMMap.EKColor)
    case gradient(gradient: IMMap.EKAttributes.BackgroundStyle.Gradient)
    case image(image: UIKit.UIImage)
    case clear
    public static func == (lhs: IMMap.EKAttributes.BackgroundStyle, rhs: IMMap.EKAttributes.BackgroundStyle) -> Swift.Bool
  }
}
public protocol ObservableConvertibleType {
  associatedtype Element
  @available(*, deprecated, renamed: "Element")
  typealias E = Self.Element
  func asObservable() -> IMMap.Observable<Self.Element>
}
extension UIStoryboard {
  public func instantiateViewController<ViewControllerResource>(withResource resource: ViewControllerResource) -> ViewControllerResource.ViewControllerType? where ViewControllerResource : IMMap.StoryboardViewControllerResourceType
}
extension SharedSequence {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> IMMap.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> IMMap.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> IMMap.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> IMMap.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> IMMap.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> IMMap.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> IMMap.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> IMMap.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> IMMap.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> IMMap.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> IMMap.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> IMMap.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> IMMap.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> IMMap.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> IMMap.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> IMMap.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> IMMap.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> IMMap.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> IMMap.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> IMMap.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> IMMap.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O7 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> IMMap.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O7 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> IMMap.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O7 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> IMMap.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O7 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> IMMap.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O7 : IMMap.SharedSequenceConvertibleType, O8 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> IMMap.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O7 : IMMap.SharedSequenceConvertibleType, O8 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> IMMap.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O7 : IMMap.SharedSequenceConvertibleType, O8 : IMMap.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> IMMap.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : IMMap.SharedSequenceConvertibleType, O2 : IMMap.SharedSequenceConvertibleType, O3 : IMMap.SharedSequenceConvertibleType, O4 : IMMap.SharedSequenceConvertibleType, O5 : IMMap.SharedSequenceConvertibleType, O6 : IMMap.SharedSequenceConvertibleType, O7 : IMMap.SharedSequenceConvertibleType, O8 : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
public protocol VirtualTimeConverterType {
  associatedtype VirtualTimeUnit
  associatedtype VirtualTimeIntervalUnit
  func convertFromVirtualTime(_ virtualTime: Self.VirtualTimeUnit) -> IMMap.RxTime
  func convertToVirtualTime(_ time: IMMap.RxTime) -> Self.VirtualTimeUnit
  func convertFromVirtualTimeInterval(_ virtualTimeInterval: Self.VirtualTimeIntervalUnit) -> Foundation.TimeInterval
  func convertToVirtualTimeInterval(_ timeInterval: Foundation.TimeInterval) -> Self.VirtualTimeIntervalUnit
  func offsetVirtualTime(_ time: Self.VirtualTimeUnit, offset: Self.VirtualTimeIntervalUnit) -> Self.VirtualTimeUnit
  func compareVirtualTime(_ lhs: Self.VirtualTimeUnit, _ rhs: Self.VirtualTimeUnit) -> IMMap.VirtualTimeComparison
}
public enum VirtualTimeComparison {
  case lessThan
  case equal
  case greaterThan
  public static func == (a: IMMap.VirtualTimeComparison, b: IMMap.VirtualTimeComparison) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension ObservableType {
  public func flatMapLatest<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> IMMap.Observable<Source.Element> where Source : IMMap.ObservableConvertibleType
}
extension ObservableType where Self.Element : IMMap.ObservableConvertibleType {
  public func switchLatest() -> IMMap.Observable<Self.Element.Element>
}
extension ControlProperty {
  public func asDriver() -> IMMap.Driver<IMMap.ControlProperty<PropertyType>.Element>
}
public protocol StoryboardResourceType {
  var bundle: Foundation.Bundle { get }
  var name: Swift.String { get }
}
public protocol StoryboardResourceWithInitialControllerType : IMMap.StoryboardResourceType {
  associatedtype InitialController
}
extension ObservableType {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> IMMap.Observable<(O1.Element, O2.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType
}
extension ObservableType {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType
}
extension ObservableType {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType
}
extension ObservableType {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType
}
extension ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType
}
extension ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType, O7 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType, O7 : IMMap.ObservableType
}
extension ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType, O7 : IMMap.ObservableType, O8 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType, O7 : IMMap.ObservableType, O8 : IMMap.ObservableType
}
extension EKAttributes {
  public typealias DisplayDuration = Foundation.TimeInterval
}
extension UIScrollView : IMMap.HasDelegate {
  public typealias Delegate = UIKit.UIScrollViewDelegate
}
open class RxScrollViewDelegateProxy : IMMap.DelegateProxy<UIKit.UIScrollView, UIKit.UIScrollViewDelegate>, IMMap.DelegateProxyType, UIKit.UIScrollViewDelegate {
  weak public var scrollView: UIKit.UIScrollView? {
    get
    }
  public init(scrollView: IMMap.RxScrollViewDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @objc deinit
  override public init<Proxy>(parentObject: UIKit.UIScrollView, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UIScrollView, UIKit.UIScrollViewDelegate>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UIScrollViewDelegate, Proxy.ParentObject == UIKit.UIScrollView
}
public class ReplaySubject<Element> : IMMap.Observable<Element>, IMMap.SubjectType, IMMap.ObserverType, IMMap.Disposable {
  public typealias SubjectObserverType = IMMap.ReplaySubject<Element>
  public var hasObservers: Swift.Bool {
    get
  }
  public func on(_ event: IMMap.Event<Element>)
  public func asObserver() -> IMMap.ReplaySubject<Element>.SubjectObserverType
  public func dispose()
  public static func create(bufferSize: Swift.Int) -> IMMap.ReplaySubject<Element>
  public static func createUnbounded() -> IMMap.ReplaySubject<Element>
  @objc deinit
  public typealias Observer = IMMap.ReplaySubject<Element>
}
extension Int : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int.KVOType)
}
extension Int32 : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int32.KVOType)
}
extension Int64 : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int64.KVOType)
}
extension UInt : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt.KVOType)
}
extension UInt32 : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt32.KVOType)
}
extension UInt64 : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt64.KVOType)
}
extension Bool : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Bool.KVOType)
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension String : IMMap.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URL : IMMap.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URLComponents : IMMap.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension URLRequest : IMMap.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension URLRequest {
  public init(url: IMMap.URLConvertible, method: IMMap.HTTPMethod, headers: IMMap.HTTPHeaders? = nil) throws
}
@discardableResult
public func request(_ url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .get, parameters: IMMap.Parameters? = nil, encoding: IMMap.ParameterEncoding = URLEncoding.default, headers: IMMap.HTTPHeaders? = nil) -> IMMap.DataRequest
@discardableResult
public func request(_ urlRequest: IMMap.URLRequestConvertible) -> IMMap.DataRequest
@discardableResult
public func download(_ url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .get, parameters: IMMap.Parameters? = nil, encoding: IMMap.ParameterEncoding = URLEncoding.default, headers: IMMap.HTTPHeaders? = nil, to destination: IMMap.DownloadRequest.DownloadFileDestination? = nil) -> IMMap.DownloadRequest
@discardableResult
public func download(_ urlRequest: IMMap.URLRequestConvertible, to destination: IMMap.DownloadRequest.DownloadFileDestination? = nil) -> IMMap.DownloadRequest
@discardableResult
public func download(resumingWith resumeData: Foundation.Data, to destination: IMMap.DownloadRequest.DownloadFileDestination? = nil) -> IMMap.DownloadRequest
@discardableResult
public func upload(_ fileURL: Foundation.URL, to url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .post, headers: IMMap.HTTPHeaders? = nil) -> IMMap.UploadRequest
@discardableResult
public func upload(_ fileURL: Foundation.URL, with urlRequest: IMMap.URLRequestConvertible) -> IMMap.UploadRequest
@discardableResult
public func upload(_ data: Foundation.Data, to url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .post, headers: IMMap.HTTPHeaders? = nil) -> IMMap.UploadRequest
@discardableResult
public func upload(_ data: Foundation.Data, with urlRequest: IMMap.URLRequestConvertible) -> IMMap.UploadRequest
@discardableResult
public func upload(_ stream: Foundation.InputStream, to url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .post, headers: IMMap.HTTPHeaders? = nil) -> IMMap.UploadRequest
@discardableResult
public func upload(_ stream: Foundation.InputStream, with urlRequest: IMMap.URLRequestConvertible) -> IMMap.UploadRequest
public func upload(multipartFormData: @escaping (IMMap.MultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold, to url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .post, headers: IMMap.HTTPHeaders? = nil, encodingCompletion: ((IMMap.SessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
public func upload(multipartFormData: @escaping (IMMap.MultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold, with urlRequest: IMMap.URLRequestConvertible, encodingCompletion: ((IMMap.SessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
@available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
@discardableResult
public func stream(withHostName hostName: Swift.String, port: Swift.Int) -> IMMap.StreamRequest
@available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
@discardableResult
public func stream(with netService: Foundation.NetService) -> IMMap.StreamRequest
extension UIImage {
  convenience public init?(resource: IMMap.ImageResourceType, compatibleWith traitCollection: UIKit.UITraitCollection? = nil)
}
extension ObservableType {
  public func reduce<A, Result>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A, mapResult: @escaping (A) throws -> Result) -> IMMap.Observable<Result>
  public func reduce<A>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A) -> IMMap.Observable<A>
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImageView {
  @discardableResult
  public func setImage(with source: IMMap.Source?, placeholder: IMMap.Placeholder? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  @discardableResult
  public func setImage(with resource: IMMap.Resource?, placeholder: IMMap.Placeholder? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  @discardableResult
  public func setImage(with provider: IMMap.ImageDataProvider?, placeholder: IMMap.Placeholder? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  public func cancelDownloadTask()
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImageView {
  public var taskIdentifier: IMMap.Source.Identifier.Value? {
    get
  }
  public var indicatorType: IMMap.IndicatorType {
    get
    set
  }
  public var indicator: IMMap.Indicator? {
    get
  }
  public var placeholder: IMMap.Placeholder? {
    get
  }
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImageView {
  @available(*, deprecated, message: "Use `taskIdentifier` instead to identify a setting task.")
  public var webURL: Foundation.URL? {
    get
  }
}
public protocol ImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
}
public struct AnyModifier : IMMap.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
  public init(modify: @escaping (Foundation.URLRequest) -> Foundation.URLRequest?)
}
final public class PublishRelay<Element> : IMMap.ObservableType {
  final public func accept(_ event: Element)
  public init()
  final public func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where Element == Observer.Element, Observer : IMMap.ObserverType
  final public func asObservable() -> IMMap.Observable<Element>
  @objc deinit
}
extension ObservableType {
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func ignoreElements() -> IMMap.Completable
}
extension CGSize : IMMap.KingfisherCompatibleValue {
}
extension KingfisherWrapper where Base == CoreGraphics.CGSize {
  public func resize(to size: CoreGraphics.CGSize, for contentMode: IMMap.ContentMode) -> CoreGraphics.CGSize
  public func constrained(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public func filling(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public func constrainedRect(for size: CoreGraphics.CGSize, anchor: CoreGraphics.CGPoint) -> CoreGraphics.CGRect
}
extension Reactive where Base : UIKit.NSTextStorage {
  public var delegate: IMMap.DelegateProxy<UIKit.NSTextStorage, UIKit.NSTextStorageDelegate> {
    get
  }
  public var didProcessEditingRangeChangeInLength: IMMap.Observable<(editedMask: UIKit.NSTextStorage.EditActions, editedRange: Foundation.NSRange, delta: Swift.Int)> {
    get
  }
}
extension ObservableType {
  public func take(_ count: Swift.Int) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func take(_ duration: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func ifEmpty(switchTo other: IMMap.Observable<Self.Element>) -> IMMap.Observable<Self.Element>
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImage {
  public func image(withBlendMode blendMode: CoreGraphics.CGBlendMode, alpha: CoreGraphics.CGFloat = 1.0, backgroundColor: IMMap.KFCrossPlatformColor? = nil) -> IMMap.KFCrossPlatformImage
  public func image(withRoundRadius radius: CoreGraphics.CGFloat, fit size: CoreGraphics.CGSize, roundingCorners corners: IMMap.RectCorner = .all, backgroundColor: IMMap.KFCrossPlatformColor? = nil) -> IMMap.KFCrossPlatformImage
  public func resize(to size: CoreGraphics.CGSize) -> IMMap.KFCrossPlatformImage
  public func resize(to targetSize: CoreGraphics.CGSize, for contentMode: IMMap.ContentMode) -> IMMap.KFCrossPlatformImage
  public func crop(to size: CoreGraphics.CGSize, anchorOn anchor: CoreGraphics.CGPoint) -> IMMap.KFCrossPlatformImage
  public func blurred(withRadius radius: CoreGraphics.CGFloat) -> IMMap.KFCrossPlatformImage
  public func overlaying(with color: IMMap.KFCrossPlatformColor, fraction: CoreGraphics.CGFloat) -> IMMap.KFCrossPlatformImage
  public func tinted(with color: IMMap.KFCrossPlatformColor) -> IMMap.KFCrossPlatformImage
  public func adjusted(brightness: CoreGraphics.CGFloat, contrast: CoreGraphics.CGFloat, saturation: CoreGraphics.CGFloat, inputEV: CoreGraphics.CGFloat) -> IMMap.KFCrossPlatformImage
  public func scaled(to scale: CoreGraphics.CGFloat) -> IMMap.KFCrossPlatformImage
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImage {
  public var decoded: IMMap.KFCrossPlatformImage {
    get
  }
  public func decoded(scale: CoreGraphics.CGFloat) -> IMMap.KFCrossPlatformImage
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImage {
}
extension EKAttributes {
  public enum Precedence {
    public struct Priority : Swift.Hashable, Swift.Equatable, Swift.RawRepresentable, Swift.Comparable {
      public var rawValue: Swift.Int
      public var hashValue: Swift.Int {
        get
      }
      public init(_ rawValue: Swift.Int)
      public init(rawValue: Swift.Int)
      public static func == (lhs: IMMap.EKAttributes.Precedence.Priority, rhs: IMMap.EKAttributes.Precedence.Priority) -> Swift.Bool
      public static func < (lhs: IMMap.EKAttributes.Precedence.Priority, rhs: IMMap.EKAttributes.Precedence.Priority) -> Swift.Bool
      public typealias RawValue = Swift.Int
    }
    public enum QueueingHeuristic {
      public static var value: IMMap.EKAttributes.Precedence.QueueingHeuristic
      case chronological
      case priority
      public static func == (a: IMMap.EKAttributes.Precedence.QueueingHeuristic, b: IMMap.EKAttributes.Precedence.QueueingHeuristic) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    case override(priority: IMMap.EKAttributes.Precedence.Priority, dropEnqueuedEntries: Swift.Bool)
    case enqueue(priority: IMMap.EKAttributes.Precedence.Priority)
    public var priority: IMMap.EKAttributes.Precedence.Priority {
      get
      set
    }
  }
}
extension EKAttributes.Precedence.Priority {
  public static let maxRawValue: Swift.Int
  public static let highRawValue: Swift.Int
  public static let normalRawValue: Swift.Int
  public static let lowRawValue: Swift.Int
  public static let minRawValue: Swift.Int
  public static let max: IMMap.EKAttributes.Precedence.Priority
  public static let high: IMMap.EKAttributes.Precedence.Priority
  public static let normal: IMMap.EKAttributes.Precedence.Priority
  public static let low: IMMap.EKAttributes.Precedence.Priority
  public static let min: IMMap.EKAttributes.Precedence.Priority
}
extension ObservableConvertibleType {
  public func asDriver(onErrorJustReturn: Self.Element) -> IMMap.Driver<Self.Element>
  public func asDriver(onErrorDriveWith: IMMap.Driver<Self.Element>) -> IMMap.Driver<Self.Element>
  public func asDriver(onErrorRecover: @escaping (Swift.Error) -> IMMap.Driver<Self.Element>) -> IMMap.Driver<Self.Element>
}
extension Disposables {
  public static func create() -> IMMap.Disposable
}
extension UIView {
  @discardableResult
  public func set(_ edge: IMMap.QLAttribute, of value: CoreGraphics.CGFloat, relation: IMMap.QLRelation = .equal, ratio: CoreGraphics.CGFloat = 1.0, priority: IMMap.QLPriority = .required) -> UIKit.NSLayoutConstraint
  @discardableResult
  public func set(_ edges: IMMap.QLAttribute..., of value: CoreGraphics.CGFloat, relation: IMMap.QLRelation = .equal, ratio: CoreGraphics.CGFloat = 1.0, priority: IMMap.QLPriority = .required) -> IMMap.QLMultipleConstraints
  @discardableResult
  public func set(_ edges: [IMMap.QLAttribute], to value: CoreGraphics.CGFloat, relation: IMMap.QLRelation = .equal, ratio: CoreGraphics.CGFloat = 1.0, priority: IMMap.QLPriority = .required) -> IMMap.QLMultipleConstraints
  @discardableResult
  public func layout(_ edge: IMMap.QLAttribute? = nil, to otherEdge: IMMap.QLAttribute, of view: IMMap.QLView, relation: IMMap.QLRelation = .equal, ratio: CoreGraphics.CGFloat = 1.0, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> UIKit.NSLayoutConstraint?
  @discardableResult
  public func layout(_ edges: IMMap.QLAttribute..., to view: IMMap.QLView, relation: IMMap.QLRelation = .equal, ratio: CoreGraphics.CGFloat = 1.0, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> IMMap.QLMultipleConstraints
  @discardableResult
  public func layoutToSuperview(_ edge: IMMap.QLAttribute, relation: IMMap.QLRelation = .equal, ratio: CoreGraphics.CGFloat = 1, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> UIKit.NSLayoutConstraint?
  @discardableResult
  public func layoutToSuperview(_ edges: IMMap.QLAttribute..., relation: IMMap.QLRelation = .equal, ratio: CoreGraphics.CGFloat = 1, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> IMMap.QLMultipleConstraints
  @discardableResult
  public func layoutToSuperview(axis: IMMap.QLAxis, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> IMMap.QLAxisConstraints?
  @discardableResult
  public func sizeToSuperview(withRatio ratio: CoreGraphics.CGFloat = 1, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> IMMap.QLSizeConstraints?
  @discardableResult
  public func centerInSuperview(offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> IMMap.QLCenterConstraints?
  @discardableResult
  public func fillSuperview(withSizeRatio ratio: CoreGraphics.CGFloat = 1, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> IMMap.QLFillConstraints?
  public var isValidForQuickLayout: Swift.Bool {
    get
  }
}
extension ObservableType {
  public func ifEmpty(default: Self.Element) -> IMMap.Observable<Self.Element>
}
public protocol ImmediateSchedulerType {
  func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
}
extension ImmediateSchedulerType {
  public func scheduleRecursive<State>(_ state: State, action: @escaping (State, (State) -> Swift.Void) -> Swift.Void) -> IMMap.Disposable
}
extension Reactive where Base : UIKit.UISwitch {
  public var isOn: IMMap.ControlProperty<Swift.Bool> {
    get
  }
  public var value: IMMap.ControlProperty<Swift.Bool> {
    get
  }
}
@objc public class EKImageNoteMessageView : IMMap.EKAccessoryNoteMessageView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public init(with content: IMMap.EKProperty.LabelContent, imageContent: IMMap.EKProperty.ImageContent)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public protocol ColorResourceType {
  var bundle: Foundation.Bundle { get }
  var name: Swift.String { get }
}
public struct ColorResource : IMMap.ColorResourceType {
  public let bundle: Foundation.Bundle
  public let name: Swift.String
  public init(bundle: Foundation.Bundle, name: Swift.String)
}
extension EKAttributes {
  public enum DisplayMode {
    case inferred
    case light
    case dark
    public static func == (a: IMMap.EKAttributes.DisplayMode, b: IMMap.EKAttributes.DisplayMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
final public class SingleAssignmentDisposable : IMMap.DisposeBase, IMMap.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  override public init()
  final public func setDisposable(_ disposable: IMMap.Disposable)
  final public func dispose()
  @objc deinit
}
extension ObservableType {
  public func startWith(_ elements: Self.Element...) -> IMMap.Observable<Self.Element>
}
@objc public class IMDataManagement : ObjectiveC.NSObject {
  @objc public static let shared: IMMap.IMDataManagement
  @objc public func setLanguageCode(_ code: Swift.String?)
  @objc override dynamic public init()
  @objc deinit
}
public struct HistoricalSchedulerTimeConverter : IMMap.VirtualTimeConverterType {
  public typealias VirtualTimeUnit = IMMap.RxTime
  public typealias VirtualTimeIntervalUnit = Foundation.TimeInterval
  public func convertFromVirtualTime(_ virtualTime: IMMap.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> IMMap.RxTime
  public func convertToVirtualTime(_ time: IMMap.RxTime) -> IMMap.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func convertFromVirtualTimeInterval(_ virtualTimeInterval: IMMap.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> Foundation.TimeInterval
  public func convertToVirtualTimeInterval(_ timeInterval: Foundation.TimeInterval) -> IMMap.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit
  public func offsetVirtualTime(_ time: IMMap.HistoricalSchedulerTimeConverter.VirtualTimeUnit, offset: IMMap.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> IMMap.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func compareVirtualTime(_ lhs: IMMap.HistoricalSchedulerTimeConverter.VirtualTimeUnit, _ rhs: IMMap.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> IMMap.VirtualTimeComparison
}
public class ConnectableObservable<Element> : IMMap.Observable<Element>, IMMap.ConnectableObservableType {
  public func connect() -> IMMap.Disposable
  @objc deinit
}
extension ObservableType {
  public func multicast<Subject, Result>(_ subjectSelector: @escaping () throws -> Subject, selector: @escaping (IMMap.Observable<Subject.Element>) throws -> IMMap.Observable<Result>) -> IMMap.Observable<Result> where Subject : IMMap.SubjectType, Self.Element == Subject.Observer.Element
}
extension ObservableType {
  public func publish() -> IMMap.ConnectableObservable<Self.Element>
}
extension ObservableType {
  public func replay(_ bufferSize: Swift.Int) -> IMMap.ConnectableObservable<Self.Element>
  public func replayAll() -> IMMap.ConnectableObservable<Self.Element>
}
extension ConnectableObservableType {
  public func refCount() -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func multicast<Subject>(_ subject: Subject) -> IMMap.ConnectableObservable<Subject.Element> where Subject : IMMap.SubjectType, Self.Element == Subject.Observer.Element
  public func multicast<Subject>(makeSubject: @escaping () -> Subject) -> IMMap.ConnectableObservable<Subject.Element> where Subject : IMMap.SubjectType, Self.Element == Subject.Observer.Element
}
extension ObservableType {
  public func skip(_ count: Swift.Int) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func skip(_ duration: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
public struct EKColor : Swift.Equatable {
  public var dark: UIKit.UIColor {
    get
    }
  public var light: UIKit.UIColor {
    get
    }
  public init(light: UIKit.UIColor, dark: UIKit.UIColor)
  public init(_ unified: UIKit.UIColor)
  public init(rgb: Swift.Int)
  public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int)
  public func color(for traits: UIKit.UITraitCollection, mode: IMMap.EKAttributes.DisplayMode) -> UIKit.UIColor
  public static func == (a: IMMap.EKColor, b: IMMap.EKColor) -> Swift.Bool
}
extension EKColor {
  public var inverted: IMMap.EKColor {
    get
  }
  public func with(alpha: CoreGraphics.CGFloat) -> IMMap.EKColor
  public static var white: IMMap.EKColor {
    get
  }
  public static var black: IMMap.EKColor {
    get
  }
  public static var clear: IMMap.EKColor {
    get
  }
  public static var standardBackground: IMMap.EKColor {
    get
  }
  public static var standardContent: IMMap.EKColor {
    get
  }
}
extension ObservableType {
  public static func create(_ subscribe: @escaping (IMMap.AnyObserver<Self.Element>) -> IMMap.Disposable) -> IMMap.Observable<Self.Element>
}
public protocol SectionedViewDataSourceType {
  func model(at indexPath: Foundation.IndexPath) throws -> Any
}
extension ObservableType {
  public static func zip<Collection>(_ collection: Collection, resultSelector: @escaping ([Collection.Element.Element]) throws -> Self.Element) -> IMMap.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element : IMMap.ObservableType
  public static func zip<Collection>(_ collection: Collection) -> IMMap.Observable<[Self.Element]> where Collection : Swift.Collection, Self.Element == Collection.Element.Element, Collection.Element : IMMap.ObservableType
}
public protocol RxPickerViewDataSourceType {
  associatedtype Element
  func pickerView(_ pickerView: UIKit.UIPickerView, observedEvent: IMMap.Event<Self.Element>)
}
extension UIFont {
  convenience public init?(resource: IMMap.FontResourceType, size: CoreGraphics.CGFloat)
}
extension ObservableType where Self.Element : IMMap.EventConvertible {
  public func dematerialize() -> IMMap.Observable<Self.Element.Element>
}
@objc public class EKAccessoryNoteMessageView : UIKit.UIView {
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol Disposable {
  func dispose()
}
@available(iOS 8.0, OSX 10.10, OSXApplicationExtension 10.10, *)
open class RxWKNavigationDelegateProxy : IMMap.DelegateProxy<WebKit.WKWebView, WebKit.WKNavigationDelegate>, IMMap.DelegateProxyType, WebKit.WKNavigationDelegate {
  weak public var webView: WebKit.WKWebView? {
    get
    }
  public init(webView: IMMap.RxWKNavigationDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  public static func currentDelegate(for object: WebKit.WKWebView) -> WebKit.WKNavigationDelegate?
  public static func setCurrentDelegate(_ delegate: WebKit.WKNavigationDelegate?, to object: WebKit.WKWebView)
  override public init<Proxy>(parentObject: WebKit.WKWebView, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<WebKit.WKWebView, WebKit.WKNavigationDelegate>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == WebKit.WKNavigationDelegate, Proxy.ParentObject == WebKit.WKWebView
  @objc deinit
}
public protocol ConnectableObservableType : IMMap.ObservableType {
  func connect() -> IMMap.Disposable
}
extension ObservableType {
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo<Observer>(_ observer: Observer) -> IMMap.Disposable where Observer : IMMap.ObserverType, Self.Element == Observer.Element
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo<Observer>(_ observer: Observer) -> IMMap.Disposable where Observer : IMMap.ObserverType, Observer.Element == Self.Element?
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo(_ variable: IMMap.Variable<Self.Element>) -> IMMap.Disposable
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo(_ variable: IMMap.Variable<Self.Element?>) -> IMMap.Disposable
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo<Result>(_ binder: (Self) -> Result) -> Result
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo<R1, R2>(_ binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  @available(*, deprecated, renamed: "bind(onNext:)")
  public func bindNext(_ onNext: @escaping (Self.Element) -> Swift.Void) -> IMMap.Disposable
}
extension NSTextStorage {
  @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDelegateProxy() -> IMMap.RxTextStorageDelegateProxy
}
extension UIScrollView {
  @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDelegateProxy() -> IMMap.RxScrollViewDelegateProxy
}
extension UICollectionView {
  @available(*, unavailable, message: "createRxDataSourceProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDataSourceProxy() -> IMMap.RxCollectionViewDataSourceProxy
}
extension UITableView {
  @available(*, unavailable, message: "createRxDataSourceProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDataSourceProxy() -> IMMap.RxTableViewDataSourceProxy
}
extension UINavigationBar {
  @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDelegateProxy() -> IMMap.RxNavigationControllerDelegateProxy
}
extension UINavigationController {
  @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDelegateProxy() -> IMMap.RxNavigationControllerDelegateProxy
}
extension UITabBar {
  @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDelegateProxy() -> IMMap.RxTabBarDelegateProxy
}
extension UITabBarController {
  @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDelegateProxy() -> IMMap.RxTabBarControllerDelegateProxy
}
extension UISearchBar {
  @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDelegateProxy() -> IMMap.RxSearchBarDelegateProxy
}
extension UISearchController {
  @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDelegateProxy() -> IMMap.RxSearchControllerDelegateProxy
}
extension UIPickerView {
  @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDelegateProxy() -> IMMap.RxPickerViewDelegateProxy
  @available(*, unavailable, message: "createRxDataSourceProxy is now unavailable, check DelegateProxyFactory")
  public func createRxDataSourceProxy() -> IMMap.RxPickerViewDataSourceProxy
}
@available(*, deprecated, renamed: "SharingScheduler.mock(scheduler:action:)")
public func driveOnScheduler(_ scheduler: IMMap.SchedulerType, action: () -> Swift.Void)
@available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
extension Variable {
  @available(*, deprecated, renamed: "asDriver()")
  final public func asSharedSequence<SharingStrategy>(strategy: SharingStrategy.Type = SharingStrategy.self) -> IMMap.SharedSequence<SharingStrategy, Element> where SharingStrategy : IMMap.SharingStrategyProtocol
}
extension DelegateProxy {
  @available(*, unavailable, renamed: "assignedProxy(for:)")
  public static func assignedProxyFor(_ object: IMMap.DelegateProxy<P, D>.ParentObject) -> IMMap.DelegateProxy<P, D>.Delegate?
  @available(*, unavailable, renamed: "currentDelegate(for:)")
  public static func currentDelegateFor(_ object: IMMap.DelegateProxy<P, D>.ParentObject) -> IMMap.DelegateProxy<P, D>.Delegate?
}
@available(*, deprecated, renamed: "Binder")
final public class UIBindingObserver<UIElement, Value> : IMMap.ObserverType where UIElement : AnyObject {
  public typealias Element = Value
  @available(*, deprecated, renamed: "UIBinder.init(_:scheduler:binding:)")
  public init(UIElement: UIElement, binding: @escaping (UIElement, Value) -> Swift.Void)
  final public func on(_ event: IMMap.Event<Value>)
  final public func asObserver() -> IMMap.AnyObserver<Value>
  @objc deinit
}
extension Reactive where Base : UIKit.UIRefreshControl {
  @available(*, deprecated, renamed: "isRefreshing")
  public var refreshing: IMMap.Binder<Swift.Bool> {
    get
  }
}
extension Reactive where Base : UIKit.UIImageView {
  @available(*, deprecated, renamed: "image")
  public func image(transitionType: Swift.String? = nil) -> IMMap.Binder<UIKit.UIImage?>
}
extension Reactive where Base : UIKit.UISegmentedControl {
  @available(*, deprecated, renamed: "enabledForSegment(at:)")
  public func enabled(forSegmentAt segmentAt: Swift.Int) -> IMMap.Binder<Swift.Bool>
}
@available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
extension Variable {
  final public func asDriver() -> IMMap.Driver<Element>
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == IMMap.DriverSharingStrategy {
  @available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
  public func drive(_ variable: IMMap.Variable<Self.Element>) -> IMMap.Disposable
  @available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
  public func drive(_ variable: IMMap.Variable<Self.Element?>) -> IMMap.Disposable
}
@available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
extension ObservableType {
  public func bind(to variable: IMMap.Variable<Self.Element>) -> IMMap.Disposable
  public func bind(to variable: IMMap.Variable<Self.Element?>) -> IMMap.Disposable
}
extension SharedSequenceConvertibleType {
  @available(*, deprecated, renamed: "timeout(_:latest:)", message: "Use DispatchTimeInterval overload instead.")
  public func throttle(_ dueTime: Foundation.TimeInterval, latest: Swift.Bool = true) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
  @available(*, deprecated, renamed: "debounce(_:)", message: "Use DispatchTimeInterval overload instead.")
  public func debounce(_ dueTime: Foundation.TimeInterval) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  @available(*, deprecated, renamed: "delay(_:)", message: "Use DispatchTimeInterval overload instead.")
  public func delay(_ dueTime: Foundation.TimeInterval) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequence where Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "interval(_:)", message: "Use DispatchTimeInterval overload instead.")
  public static func interval(_ period: Foundation.TimeInterval) -> IMMap.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence where Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "timer(_:)", message: "Use DispatchTimeInterval overload instead.")
  public static func timer(_ dueTime: Foundation.TimeInterval, period: Foundation.TimeInterval) -> IMMap.SharedSequence<SharingStrategy, Element>
}
extension ObservableType {
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, observableFactory: @escaping (Resource) throws -> IMMap.Observable<Self.Element>) -> IMMap.Observable<Self.Element> where Resource : IMMap.Disposable
}
@objc final public class EKRatingSymbolView : UIKit.UIView {
  final public var isSelected: Swift.Bool {
    get
    set
  }
  public init(unselectedImage: IMMap.EKProperty.ImageContent, selectedImage: IMMap.EKProperty.ImageContent, selection: @escaping IMMap.EKRatingMessage.Selection)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension UITabBarController : IMMap.HasDelegate {
  public typealias Delegate = UIKit.UITabBarControllerDelegate
}
open class RxTabBarControllerDelegateProxy : IMMap.DelegateProxy<UIKit.UITabBarController, UIKit.UITabBarControllerDelegate>, IMMap.DelegateProxyType, UIKit.UITabBarControllerDelegate {
  weak public var tabBar: UIKit.UITabBarController? {
    get
    }
  public init(tabBar: IMMap.RxTabBarControllerDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  override public init<Proxy>(parentObject: UIKit.UITabBarController, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UITabBarController, UIKit.UITabBarControllerDelegate>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UITabBarControllerDelegate, Proxy.ParentObject == UIKit.UITabBarController
  @objc deinit
}
extension ControlEvent {
  public func asSignal() -> IMMap.Signal<IMMap.ControlEvent<PropertyType>.Element>
}
extension EKAttributes {
  public struct Animation : Swift.Equatable {
    public struct Spring : Swift.Equatable {
      public var damping: CoreGraphics.CGFloat
      public var initialVelocity: CoreGraphics.CGFloat
      public init(damping: CoreGraphics.CGFloat, initialVelocity: CoreGraphics.CGFloat)
      public static func == (a: IMMap.EKAttributes.Animation.Spring, b: IMMap.EKAttributes.Animation.Spring) -> Swift.Bool
    }
    public struct RangeAnimation : Swift.Equatable {
      public var duration: Foundation.TimeInterval
      public var delay: Foundation.TimeInterval
      public var start: CoreGraphics.CGFloat
      public var end: CoreGraphics.CGFloat
      public var spring: IMMap.EKAttributes.Animation.Spring?
      public init(from start: CoreGraphics.CGFloat, to end: CoreGraphics.CGFloat, duration: Foundation.TimeInterval, delay: Foundation.TimeInterval = 0, spring: IMMap.EKAttributes.Animation.Spring? = nil)
      public static func == (a: IMMap.EKAttributes.Animation.RangeAnimation, b: IMMap.EKAttributes.Animation.RangeAnimation) -> Swift.Bool
    }
    public struct Translate : Swift.Equatable {
      public enum AnchorPosition : Swift.Equatable {
        case top
        case bottom
        case automatic
        public var hashValue: Swift.Int {
          get
        }
        public func hash(into hasher: inout Swift.Hasher)
        public static func == (a: IMMap.EKAttributes.Animation.Translate.AnchorPosition, b: IMMap.EKAttributes.Animation.Translate.AnchorPosition) -> Swift.Bool
      }
      public var duration: Foundation.TimeInterval
      public var delay: Foundation.TimeInterval
      public var anchorPosition: IMMap.EKAttributes.Animation.Translate.AnchorPosition
      public var spring: IMMap.EKAttributes.Animation.Spring?
      public init(duration: Foundation.TimeInterval, anchorPosition: IMMap.EKAttributes.Animation.Translate.AnchorPosition = .automatic, delay: Foundation.TimeInterval = 0, spring: IMMap.EKAttributes.Animation.Spring? = nil)
      public static func == (a: IMMap.EKAttributes.Animation.Translate, b: IMMap.EKAttributes.Animation.Translate) -> Swift.Bool
    }
    public var translate: IMMap.EKAttributes.Animation.Translate?
    public var scale: IMMap.EKAttributes.Animation.RangeAnimation?
    public var fade: IMMap.EKAttributes.Animation.RangeAnimation?
    public var containsTranslation: Swift.Bool {
      get
    }
    public var containsScale: Swift.Bool {
      get
    }
    public var containsFade: Swift.Bool {
      get
    }
    public var containsAnimation: Swift.Bool {
      get
    }
    public var maxDelay: Foundation.TimeInterval {
      get
    }
    public var maxDuration: Foundation.TimeInterval {
      get
    }
    public var totalDuration: Foundation.TimeInterval {
      get
    }
    public static var translation: IMMap.EKAttributes.Animation {
      get
    }
    public static var none: IMMap.EKAttributes.Animation {
      get
    }
    public init(translate: IMMap.EKAttributes.Animation.Translate? = nil, scale: IMMap.EKAttributes.Animation.RangeAnimation? = nil, fade: IMMap.EKAttributes.Animation.RangeAnimation? = nil)
    public static func == (a: IMMap.EKAttributes.Animation, b: IMMap.EKAttributes.Animation) -> Swift.Bool
  }
}
extension EKAttributes {
  public static var `default`: IMMap.EKAttributes
  public static var toast: IMMap.EKAttributes {
    get
  }
  public static var float: IMMap.EKAttributes {
    get
  }
  public static var topFloat: IMMap.EKAttributes {
    get
  }
  public static var bottomFloat: IMMap.EKAttributes {
    get
  }
  public static var centerFloat: IMMap.EKAttributes {
    get
  }
  public static var bottomToast: IMMap.EKAttributes {
    get
  }
  public static var topToast: IMMap.EKAttributes {
    get
  }
  public static var topNote: IMMap.EKAttributes {
    get
  }
  public static var bottomNote: IMMap.EKAttributes {
    get
  }
  public static var statusBar: IMMap.EKAttributes {
    get
  }
}
extension EKAttributes {
  public struct PositionConstraints {
    public enum SafeArea {
      case overridden
      case empty(fillSafeArea: Swift.Bool)
      public var isOverridden: Swift.Bool {
        get
      }
    }
    public enum Edge {
      case ratio(value: CoreGraphics.CGFloat)
      case offset(value: CoreGraphics.CGFloat)
      case constant(value: CoreGraphics.CGFloat)
      case intrinsic
      public static var fill: IMMap.EKAttributes.PositionConstraints.Edge {
        get
      }
    }
    public struct Size {
      public var width: IMMap.EKAttributes.PositionConstraints.Edge
      public var height: IMMap.EKAttributes.PositionConstraints.Edge
      public init(width: IMMap.EKAttributes.PositionConstraints.Edge, height: IMMap.EKAttributes.PositionConstraints.Edge)
      public static var intrinsic: IMMap.EKAttributes.PositionConstraints.Size {
        get
      }
      public static var sizeToWidth: IMMap.EKAttributes.PositionConstraints.Size {
        get
      }
      public static var screen: IMMap.EKAttributes.PositionConstraints.Size {
        get
      }
    }
    public enum KeyboardRelation {
      public struct Offset {
        public var bottom: CoreGraphics.CGFloat
        public var screenEdgeResistance: CoreGraphics.CGFloat?
        public init(bottom: CoreGraphics.CGFloat = 0, screenEdgeResistance: CoreGraphics.CGFloat? = nil)
        public static var none: IMMap.EKAttributes.PositionConstraints.KeyboardRelation.Offset {
          get
        }
      }
      case bind(offset: IMMap.EKAttributes.PositionConstraints.KeyboardRelation.Offset)
      case unbind
      public var isBound: Swift.Bool {
        get
      }
    }
    public struct Rotation {
      public enum SupportedInterfaceOrientation {
        case standard
        case all
        public static func == (a: IMMap.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation, b: IMMap.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation) -> Swift.Bool
        public var hashValue: Swift.Int {
          get
        }
        public func hash(into hasher: inout Swift.Hasher)
      }
      public var isEnabled: Swift.Bool
      public var supportedInterfaceOrientations: IMMap.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation
      public init()
    }
    public var rotation: IMMap.EKAttributes.PositionConstraints.Rotation
    public var keyboardRelation: IMMap.EKAttributes.PositionConstraints.KeyboardRelation
    public var size: IMMap.EKAttributes.PositionConstraints.Size
    public var maxSize: IMMap.EKAttributes.PositionConstraints.Size
    public var verticalOffset: CoreGraphics.CGFloat
    public var safeArea: IMMap.EKAttributes.PositionConstraints.SafeArea
    public var hasVerticalOffset: Swift.Bool {
      get
    }
    public static var float: IMMap.EKAttributes.PositionConstraints {
      get
    }
    public static var fullWidth: IMMap.EKAttributes.PositionConstraints {
      get
    }
    public static var fullScreen: IMMap.EKAttributes.PositionConstraints {
      get
    }
    public init(verticalOffset: CoreGraphics.CGFloat = 0, size: IMMap.EKAttributes.PositionConstraints.Size = .sizeToWidth, maxSize: IMMap.EKAttributes.PositionConstraints.Size = .intrinsic)
  }
}
extension ObservableType {
  public static func repeatElement(_ element: Self.Element, scheduler: IMMap.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> IMMap.Observable<Self.Element>
}
@objc public class EKSimpleMessageView : UIKit.UIView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension NSTextStorage : IMMap.HasDelegate {
  public typealias Delegate = UIKit.NSTextStorageDelegate
}
open class RxTextStorageDelegateProxy : IMMap.DelegateProxy<UIKit.NSTextStorage, UIKit.NSTextStorageDelegate>, IMMap.DelegateProxyType, UIKit.NSTextStorageDelegate {
  weak public var textStorage: UIKit.NSTextStorage? {
    get
    }
  public init(textStorage: UIKit.NSTextStorage)
  public static func registerKnownImplementations()
  override public init<Proxy>(parentObject: UIKit.NSTextStorage, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.NSTextStorage, UIKit.NSTextStorageDelegate>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.NSTextStorageDelegate, Proxy.ParentObject == UIKit.NSTextStorage
  @objc deinit
}
public class ConcurrentDispatchQueueScheduler : IMMap.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  public init(queue: Dispatch.DispatchQueue, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  @available(iOS 8, OSX 10.10, *)
  convenience public init(qos: Dispatch.DispatchQoS, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: IMMap.RxTimeInterval, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: IMMap.RxTimeInterval, period: IMMap.RxTimeInterval, action: @escaping (StateType) -> StateType) -> IMMap.Disposable
  @objc deinit
}
extension ObservableType {
  public func elementAt(_ index: Swift.Int) -> IMMap.Observable<Self.Element>
}
public enum ImageFormat {
  case unknown
  case PNG
  case JPEG
  case GIF
  public enum JPEGMarker {
    case SOF0
    case SOF2
    case DHT
    case DQT
    case DRI
    case SOS
    case RSTn(Swift.UInt8)
    case APPn
    case COM
    case EOI
  }
  public static func == (a: IMMap.ImageFormat, b: IMMap.ImageFormat) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension Data : IMMap.KingfisherCompatibleValue {
}
extension KingfisherWrapper where Base == Foundation.Data {
  public var imageFormat: IMMap.ImageFormat {
    get
  }
  public func contains(jpeg marker: IMMap.ImageFormat.JPEGMarker) -> Swift.Bool
}
public enum StorageExpiration {
  case never
  case seconds(Foundation.TimeInterval)
  case days(Swift.Int)
  case date(Foundation.Date)
  case expired
}
public enum ExpirationExtending {
  case none
  case cacheTime
  case expirationTime(_: IMMap.StorageExpiration)
}
public protocol CacheCostCalculable {
  var cacheCost: Swift.Int { get }
}
public protocol DataTransformable {
  func toData() throws -> Foundation.Data
  static func fromData(_ data: Foundation.Data) throws -> Self
  static var empty: Self { get }
}
public struct Binder<Value> : IMMap.ObserverType {
  public typealias Element = Value
  public init<Target>(_ target: Target, scheduler: IMMap.ImmediateSchedulerType = MainScheduler(), binding: @escaping (Target, Value) -> Swift.Void) where Target : AnyObject
  public func on(_ event: IMMap.Event<Value>)
  public func asObserver() -> IMMap.AnyObserver<Value>
}
extension StoryboardResourceWithInitialControllerType {
  public func instantiateInitialViewController() -> Self.InitialController?
}
public enum Hooks {
  public static var recordCallStackOnError: Swift.Bool
}
public typealias RxTimeInterval = Dispatch.DispatchTimeInterval
public typealias RxTime = Foundation.Date
public protocol SchedulerType : IMMap.ImmediateSchedulerType {
  var now: IMMap.RxTime { get }
  func scheduleRelative<StateType>(_ state: StateType, dueTime: IMMap.RxTimeInterval, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  func schedulePeriodic<StateType>(_ state: StateType, startAfter: IMMap.RxTimeInterval, period: IMMap.RxTimeInterval, action: @escaping (StateType) -> StateType) -> IMMap.Disposable
}
extension SchedulerType {
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: IMMap.RxTimeInterval, period: IMMap.RxTimeInterval, action: @escaping (StateType) -> StateType) -> IMMap.Disposable
}
extension ObservableType {
  public func delaySubscription(_ dueTime: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
public struct ImageCreatingOptions {
  public let scale: CoreGraphics.CGFloat
  public let duration: Foundation.TimeInterval
  public let preloadAll: Swift.Bool
  public let onlyFirstFrame: Swift.Bool
  public init(scale: CoreGraphics.CGFloat = 1.0, duration: Foundation.TimeInterval = 0.0, preloadAll: Swift.Bool = false, onlyFirstFrame: Swift.Bool = false)
}
extension Reactive where Base : UIKit.UILabel {
  public var text: IMMap.Binder<Swift.String?> {
    get
  }
  public var attributedText: IMMap.Binder<Foundation.NSAttributedString?> {
    get
  }
}
public protocol ControlPropertyType : IMMap.ObservableType, IMMap.ObserverType {
  func asControlProperty() -> IMMap.ControlProperty<Self.Element>
}
public struct ControlProperty<PropertyType> : IMMap.ControlPropertyType {
  public typealias Element = PropertyType
  public init<Values, Sink>(values: Values, valueSink: Sink) where PropertyType == Values.Element, Values : IMMap.ObservableType, Sink : IMMap.ObserverType, Values.Element == Sink.Element
  public func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where PropertyType == Observer.Element, Observer : IMMap.ObserverType
  public var changed: IMMap.ControlEvent<PropertyType> {
    get
  }
  public func asObservable() -> IMMap.Observable<IMMap.ControlProperty<PropertyType>.Element>
  public func asControlProperty() -> IMMap.ControlProperty<IMMap.ControlProperty<PropertyType>.Element>
  public func on(_ event: IMMap.Event<IMMap.ControlProperty<PropertyType>.Element>)
}
extension ControlPropertyType where Self.Element == Swift.String? {
  public var orEmpty: IMMap.ControlProperty<Swift.String> {
    get
  }
}
@available(iOS 11.0, tvOS 11.0, *)
extension UIColor {
  convenience public init?(resource: IMMap.ColorResourceType, compatibleWith traitCollection: UIKit.UITraitCollection? = nil)
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> IMMap.AFResult<Self.SerializedObject> { get }
}
public struct DataResponseSerializer<Value> : IMMap.DataResponseSerializerProtocol {
  public typealias SerializedObject = Value
  public var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> IMMap.AFResult<Value>
  public init(serializeResponse: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> IMMap.AFResult<Value>)
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> IMMap.AFResult<Self.SerializedObject> { get }
}
public struct DownloadResponseSerializer<Value> : IMMap.DownloadResponseSerializerProtocol {
  public typealias SerializedObject = Value
  public var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> IMMap.AFResult<Value>
  public init(serializeResponse: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> IMMap.AFResult<Value>)
}
extension DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (IMMap.DefaultDataResponse) -> Swift.Void) -> Self
  @discardableResult
  public func response<T>(queue: Dispatch.DispatchQueue? = nil, responseSerializer: T, completionHandler: @escaping (IMMap.DataResponse<T.SerializedObject>) -> Swift.Void) -> Self where T : IMMap.DataResponseSerializerProtocol
}
extension DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (IMMap.DefaultDownloadResponse) -> Swift.Void) -> Self
  @discardableResult
  public func response<T>(queue: Dispatch.DispatchQueue? = nil, responseSerializer: T, completionHandler: @escaping (IMMap.DownloadResponse<T.SerializedObject>) -> Swift.Void) -> Self where T : IMMap.DownloadResponseSerializerProtocol
}
extension Request {
  public static func serializeResponseData(response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> IMMap.AFResult<Foundation.Data>
}
extension DataRequest {
  public static func dataResponseSerializer() -> IMMap.DataResponseSerializer<Foundation.Data>
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (IMMap.DataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  public static func dataResponseSerializer() -> IMMap.DownloadResponseSerializer<Foundation.Data>
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (IMMap.DownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension Request {
  public static func serializeResponseString(encoding: Swift.String.Encoding?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> IMMap.AFResult<Swift.String>
}
extension DataRequest {
  public static func stringResponseSerializer(encoding: Swift.String.Encoding? = nil) -> IMMap.DataResponseSerializer<Swift.String>
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue? = nil, encoding: Swift.String.Encoding? = nil, completionHandler: @escaping (IMMap.DataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  public static func stringResponseSerializer(encoding: Swift.String.Encoding? = nil) -> IMMap.DownloadResponseSerializer<Swift.String>
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue? = nil, encoding: Swift.String.Encoding? = nil, completionHandler: @escaping (IMMap.DownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
extension Request {
  public static func serializeResponseJSON(options: Foundation.JSONSerialization.ReadingOptions, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> IMMap.AFResult<Any>
}
extension DataRequest {
  public static func jsonResponseSerializer(options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) -> IMMap.DataResponseSerializer<Any>
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue? = nil, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (IMMap.DataResponse<Any>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  public static func jsonResponseSerializer(options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) -> IMMap.DownloadResponseSerializer<Any>
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue? = nil, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (IMMap.DownloadResponse<Any>) -> Swift.Void) -> Self
}
extension Request {
  public static func serializeResponsePropertyList(options: Foundation.PropertyListSerialization.ReadOptions, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> IMMap.AFResult<Any>
}
extension DataRequest {
  public static func propertyListResponseSerializer(options: Foundation.PropertyListSerialization.ReadOptions = []) -> IMMap.DataResponseSerializer<Any>
  @discardableResult
  public func responsePropertyList(queue: Dispatch.DispatchQueue? = nil, options: Foundation.PropertyListSerialization.ReadOptions = [], completionHandler: @escaping (IMMap.DataResponse<Any>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  public static func propertyListResponseSerializer(options: Foundation.PropertyListSerialization.ReadOptions = []) -> IMMap.DownloadResponseSerializer<Any>
  @discardableResult
  public func responsePropertyList(queue: Dispatch.DispatchQueue? = nil, options: Foundation.PropertyListSerialization.ReadOptions = [], completionHandler: @escaping (IMMap.DownloadResponse<Any>) -> Swift.Void) -> Self
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == IMMap.DriverSharingStrategy {
  public func drive<Observer>(_ observer: Observer) -> IMMap.Disposable where Observer : IMMap.ObserverType, Self.Element == Observer.Element
  public func drive<Observer>(_ observer: Observer) -> IMMap.Disposable where Observer : IMMap.ObserverType, Observer.Element == Self.Element?
  public func drive(_ relay: IMMap.BehaviorRelay<Self.Element>) -> IMMap.Disposable
  public func drive(_ relay: IMMap.BehaviorRelay<Self.Element?>) -> IMMap.Disposable
  public func drive<Result>(_ transformation: (IMMap.Observable<Self.Element>) -> Result) -> Result
  public func drive<R1, R2>(_ with: (IMMap.Observable<Self.Element>) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func drive(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> IMMap.Disposable
}
extension ObservableType {
  public func groupBy<Key>(keySelector: @escaping (Self.Element) throws -> Key) -> IMMap.Observable<IMMap.GroupedObservable<Key, Self.Element>> where Key : Swift.Hashable
}
final public class SerialDisposable : IMMap.DisposeBase, IMMap.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  override public init()
  final public var disposable: IMMap.Disposable {
    get
    set(newDisposable)
  }
  final public func dispose()
  @objc deinit
}
final public class SwiftEntryKit {
  public enum EntryDismissalDescriptor {
    case specific(entryName: Swift.String)
    case prioritizedLowerOrEqualTo(priority: IMMap.EKAttributes.Precedence.Priority)
    case enqueued
    case all
    case displayed
  }
  public enum RollbackWindow {
    case main
    case custom(window: UIKit.UIWindow)
  }
  public typealias DismissCompletionHandler = () -> Swift.Void
  final public class var window: UIKit.UIWindow? {
    get
  }
  final public class var isCurrentlyDisplaying: Swift.Bool {
    get
  }
  final public class func isCurrentlyDisplaying(entryNamed name: Swift.String? = nil) -> Swift.Bool
  final public class var isQueueEmpty: Swift.Bool {
    get
  }
  final public class func queueContains(entryNamed name: Swift.String? = nil) -> Swift.Bool
  final public class func display(entry view: UIKit.UIView, using attributes: IMMap.EKAttributes, presentInsideKeyWindow: Swift.Bool = false, rollbackWindow: IMMap.SwiftEntryKit.RollbackWindow = .main)
  final public class func display(entry viewController: UIKit.UIViewController, using attributes: IMMap.EKAttributes, presentInsideKeyWindow: Swift.Bool = false, rollbackWindow: IMMap.SwiftEntryKit.RollbackWindow = .main)
  final public class func transform(to view: UIKit.UIView)
  final public class func dismiss(_ descriptor: IMMap.SwiftEntryKit.EntryDismissalDescriptor = .displayed, with completion: IMMap.SwiftEntryKit.DismissCompletionHandler? = nil)
  final public class func layoutIfNeeded()
  @objc deinit
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, _ source7: IMMap.PrimitiveSequence<Self.Trait, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, _ source7: IMMap.PrimitiveSequence<Self.Trait, E7>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, _ source7: IMMap.PrimitiveSequence<Self.Trait, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, _ source7: IMMap.PrimitiveSequence<Self.Trait, E7>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, _ source7: IMMap.PrimitiveSequence<Self.Trait, E7>, _ source8: IMMap.PrimitiveSequence<Self.Trait, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, _ source7: IMMap.PrimitiveSequence<Self.Trait, E7>, _ source8: IMMap.PrimitiveSequence<Self.Trait, E8>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, _ source7: IMMap.PrimitiveSequence<Self.Trait, E7>, _ source8: IMMap.PrimitiveSequence<Self.Trait, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequenceType where Self.Element == Any, Self.Trait == IMMap.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: IMMap.PrimitiveSequence<Self.Trait, E1>, _ source2: IMMap.PrimitiveSequence<Self.Trait, E2>, _ source3: IMMap.PrimitiveSequence<Self.Trait, E3>, _ source4: IMMap.PrimitiveSequence<Self.Trait, E4>, _ source5: IMMap.PrimitiveSequence<Self.Trait, E5>, _ source6: IMMap.PrimitiveSequence<Self.Trait, E6>, _ source7: IMMap.PrimitiveSequence<Self.Trait, E7>, _ source8: IMMap.PrimitiveSequence<Self.Trait, E8>) -> IMMap.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
@objc public class EKNoteMessageView : UIKit.UIView {
  public var horizontalOffset: CoreGraphics.CGFloat {
    get
    set
  }
  public var verticalOffset: CoreGraphics.CGFloat {
    get
    set
  }
  public init(with content: IMMap.EKProperty.LabelContent)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public typealias KFCrossPlatformImage = UIKit.UIImage
public typealias KFCrossPlatformColor = UIKit.UIColor
public typealias KFCrossPlatformImageView = UIKit.UIImageView
public typealias KFCrossPlatformView = UIKit.UIView
public typealias KFCrossPlatformButton = UIKit.UIButton
public struct KingfisherWrapper<Base> {
  public let base: Base
  public init(_ base: Base)
}
public protocol KingfisherCompatible : AnyObject {
}
public protocol KingfisherCompatibleValue {
}
extension KingfisherCompatible {
  public var kf: IMMap.KingfisherWrapper<Self> {
    get
    set
  }
}
extension KingfisherCompatibleValue {
  public var kf: IMMap.KingfisherWrapper<Self> {
    get
    set
  }
}
extension UIImage : IMMap.KingfisherCompatible {
}
extension UIImageView : IMMap.KingfisherCompatible {
}
extension UIButton : IMMap.KingfisherCompatible {
}
extension NSTextAttachment : IMMap.KingfisherCompatible {
}
extension Reactive where Base : UIKit.UITextView {
  public var text: IMMap.ControlProperty<Swift.String?> {
    get
  }
  public var value: IMMap.ControlProperty<Swift.String?> {
    get
  }
  public var attributedText: IMMap.ControlProperty<Foundation.NSAttributedString?> {
    get
  }
  public var didBeginEditing: IMMap.ControlEvent<()> {
    get
  }
  public var didEndEditing: IMMap.ControlEvent<()> {
    get
  }
  public var didChange: IMMap.ControlEvent<()> {
    get
  }
  public var didChangeSelection: IMMap.ControlEvent<()> {
    get
  }
}
extension UITableView {
  public func dequeueReusableCell<Identifier>(withIdentifier identifier: Identifier, for indexPath: Foundation.IndexPath) -> Identifier.ReusableType? where Identifier : IMMap.ReuseIdentifierType, Identifier.ReusableType : UIKit.UITableViewCell
  @available(*, unavailable, message: "Use dequeueReusableCell(withIdentifier:for:) instead")
  public func dequeueReusableCell<Identifier>(withIdentifier identifier: Identifier) -> Identifier.ReusableType? where Identifier : IMMap.ReuseIdentifierType, Identifier.ReusableType : UIKit.UITableViewCell
  public func dequeueReusableHeaderFooterView<Identifier>(withIdentifier identifier: Identifier) -> Identifier.ReusableType? where Identifier : IMMap.ReuseIdentifierType, Identifier.ReusableType : UIKit.UITableViewHeaderFooterView
  public func register<Resource>(_ nibResource: Resource) where Resource : IMMap.NibResourceType, Resource : IMMap.ReuseIdentifierType, Resource.ReusableType : UIKit.UITableViewCell
  public func registerHeaderFooterView<Resource>(_ nibResource: Resource) where Resource : IMMap.NibResourceType, Resource : IMMap.ReuseIdentifierType, Resource.ReusableType : UIKit.UIView
}
extension KingfisherWrapper where Base : UIKit.UIButton {
  @discardableResult
  public func setImage(with source: IMMap.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  @discardableResult
  public func setImage(with resource: IMMap.Resource?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  public func cancelImageDownloadTask()
  @discardableResult
  public func setBackgroundImage(with source: IMMap.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  @discardableResult
  public func setBackgroundImage(with resource: IMMap.Resource?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  public func cancelBackgroundImageDownloadTask()
}
extension KingfisherWrapper where Base : UIKit.UIButton {
  public func taskIdentifier(for state: UIKit.UIControl.State) -> IMMap.Source.Identifier.Value?
}
extension KingfisherWrapper where Base : UIKit.UIButton {
  public func backgroundTaskIdentifier(for state: UIKit.UIControl.State) -> IMMap.Source.Identifier.Value?
}
extension KingfisherWrapper where Base : UIKit.UIButton {
  @available(*, deprecated, message: "Use `taskIdentifier` instead to identify a setting task.")
  public func webURL(for state: UIKit.UIControl.State) -> Foundation.URL?
  @available(*, deprecated, message: "Use `backgroundTaskIdentifier` instead to identify a setting task.")
  public func backgroundWebURL(for state: UIKit.UIControl.State) -> Foundation.URL?
}
public struct EKPopUpMessage {
  public typealias EKPopUpMessageAction = () -> ()
  public struct ThemeImage {
    public enum Position {
      case topToTop(offset: CoreGraphics.CGFloat)
      case centerToTop(offset: CoreGraphics.CGFloat)
    }
    public var image: IMMap.EKProperty.ImageContent
    public var position: IMMap.EKPopUpMessage.ThemeImage.Position
    public init(image: IMMap.EKProperty.ImageContent, position: IMMap.EKPopUpMessage.ThemeImage.Position = .topToTop(offset: 40))
  }
  public var themeImage: IMMap.EKPopUpMessage.ThemeImage?
  public var title: IMMap.EKProperty.LabelContent
  public var description: IMMap.EKProperty.LabelContent
  public var button: IMMap.EKProperty.ButtonContent
  public var action: IMMap.EKPopUpMessage.EKPopUpMessageAction
  public init(themeImage: IMMap.EKPopUpMessage.ThemeImage? = nil, title: IMMap.EKProperty.LabelContent, description: IMMap.EKProperty.LabelContent, button: IMMap.EKProperty.ButtonContent, action: @escaping IMMap.EKPopUpMessage.EKPopUpMessageAction)
}
extension ObservableType {
  public func delay(_ dueTime: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension UIView {
  public func forceContentWrap(_ axes: IMMap.QLAxis...)
  public func forceContentWrap()
  public var verticalHuggingPriority: IMMap.QLPriority {
    get
    set
  }
  public var horizontalHuggingPriority: IMMap.QLPriority {
    get
    set
  }
  public var contentHuggingPriority: IMMap.QLPriorityPair {
    get
    set
  }
  public var verticalCompressionResistancePriority: IMMap.QLPriority {
    get
    set
  }
  public var horizontalCompressionResistancePriority: IMMap.QLPriority {
    get
    set
  }
  public var contentCompressionResistancePriority: IMMap.QLPriorityPair {
    get
    set
  }
}
public struct DefaultDataResponse {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let error: Swift.Error?
  public let timeline: IMMap.Timeline
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?, timeline: IMMap.Timeline = Timeline(), metrics: Swift.AnyObject? = nil)
}
public struct DataResponse<Value> {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let result: IMMap.AFResult<Value>
  public let timeline: IMMap.Timeline
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, result: IMMap.AFResult<Value>, timeline: IMMap.Timeline = Timeline())
}
extension DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension DataResponse {
  public func map<T>(_ transform: (Value) -> T) -> IMMap.DataResponse<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> IMMap.DataResponse<T>
  public func mapError<E>(_ transform: (Swift.Error) -> E) -> IMMap.DataResponse<Value> where E : Swift.Error
  public func flatMapError<E>(_ transform: (Swift.Error) throws -> E) -> IMMap.DataResponse<Value> where E : Swift.Error
}
public struct DefaultDownloadResponse {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let temporaryURL: Foundation.URL?
  public let destinationURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let error: Swift.Error?
  public let timeline: IMMap.Timeline
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, temporaryURL: Foundation.URL?, destinationURL: Foundation.URL?, resumeData: Foundation.Data?, error: Swift.Error?, timeline: IMMap.Timeline = Timeline(), metrics: Swift.AnyObject? = nil)
}
public struct DownloadResponse<Value> {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let temporaryURL: Foundation.URL?
  public let destinationURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let result: IMMap.AFResult<Value>
  public let timeline: IMMap.Timeline
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, temporaryURL: Foundation.URL?, destinationURL: Foundation.URL?, resumeData: Foundation.Data?, result: IMMap.AFResult<Value>, timeline: IMMap.Timeline = Timeline())
}
extension DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension DownloadResponse {
  public func map<T>(_ transform: (Value) -> T) -> IMMap.DownloadResponse<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> IMMap.DownloadResponse<T>
  public func mapError<E>(_ transform: (Swift.Error) -> E) -> IMMap.DownloadResponse<Value> where E : Swift.Error
  public func flatMapError<E>(_ transform: (Swift.Error) throws -> E) -> IMMap.DownloadResponse<Value> where E : Swift.Error
}
@available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
extension DefaultDataResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
extension DataResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
extension DefaultDownloadResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
extension DownloadResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
extension Disposable {
  public func disposed(by bag: IMMap.DisposeBag)
}
final public class DisposeBag : IMMap.DisposeBase {
  override public init()
  final public func insert(_ disposable: IMMap.Disposable)
  @objc deinit
}
extension DisposeBag {
  convenience public init(disposing disposables: IMMap.Disposable...)
  convenience public init(disposing disposables: [IMMap.Disposable])
  final public func insert(_ disposables: IMMap.Disposable...)
  final public func insert(_ disposables: [IMMap.Disposable])
}
extension UINib {
  convenience public init(resource: IMMap.NibResourceType)
}
extension Reactive where Base : UIKit.UIStepper {
  public var value: IMMap.ControlProperty<Swift.Double> {
    get
  }
  public var stepValue: IMMap.Binder<Swift.Double> {
    get
  }
}
extension ObservableType {
  public func buffer(timeSpan: IMMap.RxTimeInterval, count: Swift.Int, scheduler: IMMap.SchedulerType) -> IMMap.Observable<[Self.Element]>
}
extension ObservableType {
  public static func deferred(_ observableFactory: @escaping () throws -> IMMap.Observable<Self.Element>) -> IMMap.Observable<Self.Element>
}
public enum DiskStorage {
  public class Backend<T> where T : IMMap.DataTransformable {
    public var config: IMMap.DiskStorage.Config
    final public let directoryURL: Foundation.URL
    public init(config: IMMap.DiskStorage.Config) throws
    public func cacheFileURL(forKey key: Swift.String) -> Foundation.URL
    @objc deinit
  }
}
extension DiskStorage {
  public struct Config {
    public var sizeLimit: Swift.UInt
    public var expiration: IMMap.StorageExpiration
    public var pathExtension: Swift.String?
    public var usesHashedFileName: Swift.Bool
    public init(name: Swift.String, sizeLimit: Swift.UInt, fileManager: Foundation.FileManager = .default, directory: Foundation.URL? = nil)
  }
}
public protocol AnimatedImageViewDelegate : AnyObject {
  func animatedImageView(_ imageView: IMMap.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  func animatedImageViewDidFinishAnimating(_ imageView: IMMap.AnimatedImageView)
}
extension AnimatedImageViewDelegate {
  public func animatedImageView(_ imageView: IMMap.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  public func animatedImageViewDidFinishAnimating(_ imageView: IMMap.AnimatedImageView)
}
@objc open class AnimatedImageView : UIKit.UIImageView {
  public enum RepeatCount : Swift.Equatable {
    case once
    case finite(count: Swift.UInt)
    case infinite
    public static func == (lhs: IMMap.AnimatedImageView.RepeatCount, rhs: IMMap.AnimatedImageView.RepeatCount) -> Swift.Bool
  }
  public var autoPlayAnimatedImage: Swift.Bool
  public var framePreloadCount: Swift.Int
  public var needsPrescaling: Swift.Bool
  public var backgroundDecode: Swift.Bool
  public var runLoopMode: Foundation.RunLoop.Mode {
    get
    set
  }
  public var repeatCount: IMMap.AnimatedImageView.RepeatCount {
    get
    set
  }
  weak public var delegate: IMMap.AnimatedImageViewDelegate?
  @objc override dynamic open var image: IMMap.KFCrossPlatformImage? {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic open var isAnimating: Swift.Bool {
    @objc get
  }
  @objc override dynamic open func startAnimating()
  @objc override dynamic open func stopAnimating()
  @objc override dynamic open func display(_ layer: QuartzCore.CALayer)
  @objc override dynamic open func didMoveToWindow()
  @objc override dynamic open func didMoveToSuperview()
  @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, macCatalyst 13.0, *)
  @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension ObservableType {
  public func subscribe(_ on: @escaping (IMMap.Event<Self.Element>) -> Swift.Void) -> IMMap.Disposable
  public func subscribe(onNext: ((Self.Element) -> Swift.Void)? = nil, onError: ((Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> IMMap.Disposable
}
extension Hooks {
  public typealias DefaultErrorHandler = ([Swift.String], Swift.Error) -> Swift.Void
  public typealias CustomCaptureSubscriptionCallstack = () -> [Swift.String]
  public static var defaultErrorHandler: IMMap.Hooks.DefaultErrorHandler {
    get
    set
  }
  public static var customCaptureSubscriptionCallstack: IMMap.Hooks.CustomCaptureSubscriptionCallstack {
    get
    set
  }
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImage {
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImage {
  public var normalized: IMMap.KFCrossPlatformImage {
    get
  }
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImage {
  public func pngRepresentation() -> Foundation.Data?
  public func jpegRepresentation(compressionQuality: CoreGraphics.CGFloat) -> Foundation.Data?
  public func gifRepresentation() -> Foundation.Data?
  public func data(format: IMMap.ImageFormat, compressionQuality: CoreGraphics.CGFloat = 1.0) -> Foundation.Data?
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImage {
  public static func animatedImage(data: Foundation.Data, options: IMMap.ImageCreatingOptions) -> IMMap.KFCrossPlatformImage?
  public static func image(data: Foundation.Data, options: IMMap.ImageCreatingOptions) -> IMMap.KFCrossPlatformImage?
  public static func downsampledImage(data: Foundation.Data, to pointSize: CoreGraphics.CGSize, scale: CoreGraphics.CGFloat) -> IMMap.KFCrossPlatformImage?
}
open class MultipartFormData {
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  public var boundary: Swift.String
  public init()
  public func append(_ data: Foundation.Data, withName name: Swift.String)
  public func append(_ data: Foundation.Data, withName name: Swift.String, mimeType: Swift.String)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: IMMap.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
public enum HTTPMethod : Swift.String {
  case options
  case get
  case head
  case post
  case put
  case patch
  case delete
  case trace
  case connect
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: IMMap.URLRequestConvertible, with parameters: IMMap.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : IMMap.ParameterEncoding {
  public enum Destination {
    case methodDependent, queryString, httpBody
    public static func == (a: IMMap.URLEncoding.Destination, b: IMMap.URLEncoding.Destination) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum ArrayEncoding {
    case brackets, noBrackets
    public static func == (a: IMMap.URLEncoding.ArrayEncoding, b: IMMap.URLEncoding.ArrayEncoding) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum BoolEncoding {
    case numeric, literal
    public static func == (a: IMMap.URLEncoding.BoolEncoding, b: IMMap.URLEncoding.BoolEncoding) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static var `default`: IMMap.URLEncoding {
    get
  }
  public static var methodDependent: IMMap.URLEncoding {
    get
  }
  public static var queryString: IMMap.URLEncoding {
    get
  }
  public static var httpBody: IMMap.URLEncoding {
    get
  }
  public let destination: IMMap.URLEncoding.Destination
  public let arrayEncoding: IMMap.URLEncoding.ArrayEncoding
  public let boolEncoding: IMMap.URLEncoding.BoolEncoding
  public init(destination: IMMap.URLEncoding.Destination = .methodDependent, arrayEncoding: IMMap.URLEncoding.ArrayEncoding = .brackets, boolEncoding: IMMap.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: IMMap.URLRequestConvertible, with parameters: IMMap.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : IMMap.ParameterEncoding {
  public static var `default`: IMMap.JSONEncoding {
    get
  }
  public static var prettyPrinted: IMMap.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: IMMap.URLRequestConvertible, with parameters: IMMap.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: IMMap.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
public struct PropertyListEncoding : IMMap.ParameterEncoding {
  public static var `default`: IMMap.PropertyListEncoding {
    get
  }
  public static var xml: IMMap.PropertyListEncoding {
    get
  }
  public static var binary: IMMap.PropertyListEncoding {
    get
  }
  public let format: Foundation.PropertyListSerialization.PropertyListFormat
  public let options: Foundation.PropertyListSerialization.WriteOptions
  public init(format: Foundation.PropertyListSerialization.PropertyListFormat = .xml, options: Foundation.PropertyListSerialization.WriteOptions = 0)
  public func encode(_ urlRequest: IMMap.URLRequestConvertible, with parameters: IMMap.Parameters?) throws -> Foundation.URLRequest
}
final public class BooleanDisposable : IMMap.Cancelable {
  public init()
  public init(isDisposed: Swift.Bool)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
  @objc deinit
}
extension NSNotification.Name {
  public struct Task {
    public static let DidResume: Foundation.Notification.Name
    public static let DidSuspend: Foundation.Notification.Name
    public static let DidCancel: Foundation.Notification.Name
    public static let DidComplete: Foundation.Notification.Name
  }
}
extension Notification {
  public struct Key {
    public static let Task: Swift.String
    public static let ResponseData: Swift.String
  }
}
extension ObservableType {
  public func withLatestFrom<Source, ResultType>(_ second: Source, resultSelector: @escaping (Self.Element, Source.Element) throws -> ResultType) -> IMMap.Observable<ResultType> where Source : IMMap.ObservableConvertibleType
  public func withLatestFrom<Source>(_ second: Source) -> IMMap.Observable<Source.Element> where Source : IMMap.ObservableConvertibleType
}
extension ObservableType {
  public func toArray() -> IMMap.Single<[Self.Element]>
}
public class Observable<Element> : IMMap.ObservableType {
  public func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where Element == Observer.Element, Observer : IMMap.ObserverType
  public func asObservable() -> IMMap.Observable<Element>
  @objc deinit
}
extension ObservableType {
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> IMMap.Observable<Result>
}
extension ObservableType {
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> IMMap.Observable<Result>
}
extension ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func interval(_ period: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: IMMap.RxTimeInterval, period: IMMap.RxTimeInterval? = nil, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
open class RxTextViewDelegateProxy : IMMap.RxScrollViewDelegateProxy, UIKit.UITextViewDelegate {
  weak public var textView: UIKit.UITextView? {
    get
    }
  public init(textView: UIKit.UITextView)
  @objc open func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  override public init(scrollView: IMMap.RxScrollViewDelegateProxy.ParentObject)
  @objc deinit
}
public enum AFResult<Value> {
  case success(Value)
  case failure(Swift.Error)
  public var isSuccess: Swift.Bool {
    get
  }
  public var isFailure: Swift.Bool {
    get
  }
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
}
extension AFResult : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AFResult : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AFResult {
  public init(value: () throws -> Value)
  public func unwrap() throws -> Value
  public func map<T>(_ transform: (Value) -> T) -> IMMap.AFResult<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> IMMap.AFResult<T>
  public func mapError<T>(_ transform: (Swift.Error) -> T) -> IMMap.AFResult<Value> where T : Swift.Error
  public func flatMapError<T>(_ transform: (Swift.Error) throws -> T) -> IMMap.AFResult<Value> where T : Swift.Error
  @discardableResult
  public func withValue(_ closure: (Value) throws -> Swift.Void) rethrows -> IMMap.AFResult<Value>
  @discardableResult
  public func withError(_ closure: (Swift.Error) throws -> Swift.Void) rethrows -> IMMap.AFResult<Value>
  @discardableResult
  public func ifSuccess(_ closure: () throws -> Swift.Void) rethrows -> IMMap.AFResult<Value>
  @discardableResult
  public func ifFailure(_ closure: () throws -> Swift.Void) rethrows -> IMMap.AFResult<Value>
}
public typealias IndicatorView = UIKit.UIView
public enum IndicatorType {
  case none
  case activity
  case image(imageData: Foundation.Data)
  case custom(indicator: IMMap.Indicator)
}
public protocol Indicator {
  func startAnimatingView()
  func stopAnimatingView()
  var centerOffset: CoreGraphics.CGPoint { get }
  var view: IMMap.IndicatorView { get }
  func sizeStrategy(in imageView: IMMap.KFCrossPlatformImageView) -> IMMap.IndicatorSizeStrategy
}
public enum IndicatorSizeStrategy {
  case intrinsicSize
  case full
  case size(CoreGraphics.CGSize)
}
extension Indicator {
  public var centerOffset: CoreGraphics.CGPoint {
    get
  }
  public func sizeStrategy(in imageView: IMMap.KFCrossPlatformImageView) -> IMMap.IndicatorSizeStrategy
}
extension UIActivityIndicatorView.Style {
}
public class RetryContext {
  final public let source: IMMap.Source
  final public let error: IMMap.KingfisherError
  public var retriedCount: Swift.Int
  public var userInfo: Any? {
    get
    }
  @objc deinit
}
public enum RetryDecision {
  case retry(userInfo: Any?)
  case stop
}
public protocol RetryStrategy {
  func retry(context: IMMap.RetryContext, retryHandler: @escaping (IMMap.RetryDecision) -> Swift.Void)
}
public struct DelayRetryStrategy : IMMap.RetryStrategy {
  public enum Interval {
    case seconds(Foundation.TimeInterval)
    case accumulated(Foundation.TimeInterval)
    case custom(block: (Swift.Int) -> Foundation.TimeInterval)
  }
  public let maxRetryCount: Swift.Int
  public let retryInterval: IMMap.DelayRetryStrategy.Interval
  public init(maxRetryCount: Swift.Int, retryInterval: IMMap.DelayRetryStrategy.Interval = .seconds(3))
  public func retry(context: IMMap.RetryContext, retryHandler: @escaping (IMMap.RetryDecision) -> Swift.Void)
}
extension Reactive where Base : UIKit.UIView {
  public var isHidden: IMMap.Binder<Swift.Bool> {
    get
  }
  public var alpha: IMMap.Binder<CoreGraphics.CGFloat> {
    get
  }
  public var backgroundColor: IMMap.Binder<UIKit.UIColor?> {
    get
  }
  public var isUserInteractionEnabled: IMMap.Binder<Swift.Bool> {
    get
  }
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest) throws -> Foundation.URLRequest
}
public typealias RequestRetryCompletion = (Swift.Bool, Foundation.TimeInterval) -> Swift.Void
public protocol RequestRetrier {
  func should(_ manager: IMMap.SessionManager, retry request: IMMap.Request, with error: Swift.Error, completion: @escaping IMMap.RequestRetryCompletion)
}
public typealias HTTPHeaders = [Swift.String : Swift.String]
open class Request {
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  open var delegate: IMMap.TaskDelegate {
    get
  }
  open var task: Foundation.URLSessionTask? {
    get
  }
  final public let session: Foundation.URLSession
  open var request: Foundation.URLRequest? {
    get
  }
  open var response: Foundation.HTTPURLResponse? {
    get
  }
  open var retryCount: Swift.UInt {
    get
    }
  @discardableResult
  open func authenticate(user: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  open func authenticate(usingCredential credential: Foundation.URLCredential) -> Self
  open class func authorizationHeader(user: Swift.String, password: Swift.String) -> (key: Swift.String, value: Swift.String)?
  open func resume()
  open func suspend()
  open func cancel()
  @objc deinit
}
extension Request : Swift.CustomStringConvertible {
  open var description: Swift.String {
    get
  }
}
extension Request : Swift.CustomDebugStringConvertible {
  open var debugDescription: Swift.String {
    get
  }
}
open class DataRequest : IMMap.Request {
  override open var request: Foundation.URLRequest? {
    get
  }
  open var progress: Foundation.Progress {
    get
  }
  @discardableResult
  open func stream(closure: ((Foundation.Data) -> Swift.Void)? = nil) -> Self
  @discardableResult
  open func downloadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping IMMap.DataRequest.ProgressHandler) -> Self
  @objc deinit
}
open class DownloadRequest : IMMap.Request {
  public struct DownloadOptions : Swift.OptionSet {
    public let rawValue: Swift.UInt
    public static let createIntermediateDirectories: IMMap.DownloadRequest.DownloadOptions
    public static let removePreviousFile: IMMap.DownloadRequest.DownloadOptions
    public init(rawValue: Swift.UInt)
    public typealias Element = IMMap.DownloadRequest.DownloadOptions
    public typealias ArrayLiteralElement = IMMap.DownloadRequest.DownloadOptions
    public typealias RawValue = Swift.UInt
  }
  public typealias DownloadFileDestination = (Foundation.URL, Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: IMMap.DownloadRequest.DownloadOptions)
  override open var request: Foundation.URLRequest? {
    get
  }
  open var resumeData: Foundation.Data? {
    get
  }
  open var progress: Foundation.Progress {
    get
  }
  override open func cancel()
  open func cancel(createResumeData: Swift.Bool)
  @discardableResult
  open func downloadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping IMMap.DownloadRequest.ProgressHandler) -> Self
  open class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask) -> IMMap.DownloadRequest.DownloadFileDestination
  @objc deinit
}
open class UploadRequest : IMMap.DataRequest {
  override open var request: Foundation.URLRequest? {
    get
  }
  open var uploadProgress: Foundation.Progress {
    get
  }
  @discardableResult
  open func uploadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping IMMap.UploadRequest.ProgressHandler) -> Self
  @objc deinit
}
@available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
open class StreamRequest : IMMap.Request {
  @objc deinit
}
extension Reactive where Base : UIKit.UIGestureRecognizer {
  public var event: IMMap.ControlEvent<Base> {
    get
  }
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImage {
  @available(*, deprecated, message: "Will be removed soon. Pass parameters with `ImageCreatingOptions`, use `image(with:options:)` instead.")
  public static func image(data: Foundation.Data, scale: CoreGraphics.CGFloat, preloadAllAnimationData: Swift.Bool, onlyFirstFrame: Swift.Bool) -> IMMap.KFCrossPlatformImage?
  @available(*, deprecated, message: "Will be removed soon. Pass parameters with `ImageCreatingOptions`, use `animatedImage(with:options:)` instead.")
  public static func animated(with data: Foundation.Data, scale: CoreGraphics.CGFloat = 1.0, duration: Foundation.TimeInterval = 0.0, preloadAll: Swift.Bool, onlyFirstFrame: Swift.Bool = false) -> IMMap.KFCrossPlatformImage?
}
@available(*, deprecated, message: "Will be removed soon. Use `Result<RetrieveImageResult>` based callback instead")
public typealias CompletionHandler = ((IMMap.KFCrossPlatformImage?, Foundation.NSError?, IMMap.CacheType, Foundation.URL?) -> Swift.Void)
@available(*, deprecated, message: "Will be removed soon. Use `Result<ImageLoadingResult>` based callback instead")
public typealias ImageDownloaderCompletionHandler = ((IMMap.KFCrossPlatformImage?, Foundation.NSError?, Foundation.URL?, Foundation.Data?) -> Swift.Void)
@available(*, deprecated, message: "Will be removed soon. Use `DownloadTask` to cancel a task.")
extension RetrieveImageTask {
  @available(*, deprecated, message: "RetrieveImageTask.empty will be removed soon. Use `nil` to represent a no task.")
  public static let empty: IMMap.RetrieveImageTask
}
extension KingfisherManager {
  @available(*, deprecated, message: "Use `Result` based callback instead.")
  @discardableResult
  public func retrieveImage(with resource: IMMap.Resource, options: IMMap.KingfisherOptionsInfo?, progressBlock: IMMap.DownloadProgressBlock?, completionHandler: IMMap.CompletionHandler?) -> IMMap.DownloadTask?
}
extension ImageDownloader {
  @available(*, deprecated, message: "Use `Result` based callback instead.")
  @discardableResult
  open func downloadImage(with url: Foundation.URL, retrieveImageTask: IMMap.RetrieveImageTask? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.ImageDownloaderProgressBlock? = nil, completionHandler: IMMap.ImageDownloaderCompletionHandler?) -> IMMap.DownloadTask?
}
@available(*, deprecated, message: "RetrieveImageDownloadTask is removed. Use `DownloadTask` to cancel a task.")
public struct RetrieveImageDownloadTask {
}
@available(*, deprecated, message: "RetrieveImageTask is removed. Use `DownloadTask` to cancel a task.")
final public class RetrieveImageTask {
  @objc deinit
}
@available(*, deprecated, renamed: "DownloadProgressBlock", message: "Use `DownloadProgressBlock` instead.")
public typealias ImageDownloaderProgressBlock = IMMap.DownloadProgressBlock
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImageView {
  @available(*, deprecated, message: "Use `Result` based callback instead.")
  @discardableResult
  public func setImage(with resource: IMMap.Resource?, placeholder: IMMap.Placeholder? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: IMMap.CompletionHandler?) -> IMMap.DownloadTask?
}
extension KingfisherWrapper where Base : UIKit.UIButton {
  @available(*, deprecated, message: "Use `Result` based callback instead.")
  @discardableResult
  public func setImage(with resource: IMMap.Resource?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: IMMap.CompletionHandler?) -> IMMap.DownloadTask?
  @available(*, deprecated, message: "Use `Result` based callback instead.")
  @discardableResult
  public func setBackgroundImage(with resource: IMMap.Resource?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: IMMap.CompletionHandler?) -> IMMap.DownloadTask?
}
extension ImageCache {
  @available(*, deprecated, renamed: "memoryStorage.config.totalCostLimit", message: "Use `memoryStorage.config.totalCostLimit` instead.")
  open var maxMemoryCost: Swift.Int {
    get
    set
  }
  @available(*, deprecated, message: "Not needed anymore.")
  final public class func defaultDiskCachePathClosure(path: Swift.String?, cacheName: Swift.String) -> Swift.String
  @available(*, deprecated, renamed: "diskStorage.config.pathExtension", message: "Use `diskStorage.config.pathExtension` instead.")
  open var pathExtension: Swift.String? {
    get
    set
  }
  @available(*, deprecated, renamed: "diskStorage.directoryURL.absoluteString", message: "Use `diskStorage.directoryURL.absoluteString` instead.")
  public var diskCachePath: Swift.String {
    get
  }
  @available(*, deprecated, renamed: "diskStorage.config.sizeLimit", message: "Use `diskStorage.config.sizeLimit` instead.")
  open var maxDiskCacheSize: Swift.UInt {
    get
    set
  }
  @available(*, deprecated, renamed: "diskStorage.cacheFileURL(forKey:)", message: "Use `diskStorage.cacheFileURL(forKey:).path` instead.")
  open func cachePath(forComputedKey key: Swift.String) -> Swift.String
  @available(*, deprecated, renamed: "retrieveImageInDiskCache(forKey:options:callbackQueue:completionHandler:)", message: "Use `Result` based `retrieveImageInDiskCache(forKey:options:callbackQueue:completionHandler:)` instead.")
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: IMMap.KingfisherOptionsInfo? = nil) -> IMMap.KFCrossPlatformImage?
  @available(*, deprecated, renamed: "retrieveImage(forKey:options:callbackQueue:completionHandler:)", message: "Use `Result` based `retrieveImage(forKey:options:callbackQueue:completionHandler:)` instead.")
  open func retrieveImage(forKey key: Swift.String, options: IMMap.KingfisherOptionsInfo?, completionHandler: ((IMMap.KFCrossPlatformImage?, IMMap.CacheType) -> Swift.Void)?)
  @available(*, deprecated, message: "Deprecated. Use `diskStorage.config.expiration` instead")
  open var maxCachePeriodInSecond: Foundation.TimeInterval {
    get
    set
  }
  @available(*, deprecated, message: "Use `Result` based callback instead.")
  open func store(_ image: IMMap.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", cacheSerializer serializer: IMMap.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true, completionHandler: (() -> Swift.Void)?)
  @available(*, deprecated, message: "Use the `Result`-based `calculateDiskStorageSize` instead.")
  open func calculateDiskCacheSize(completion handler: @escaping ((Swift.UInt) -> Swift.Void))
}
extension Collection where Self.Element == IMMap.KingfisherOptionsInfoItem {
  @available(*, deprecated, renamed: "callbackQueue", message: "Use `callbackQueue` instead.")
  public var callbackDispatchQueue: Dispatch.DispatchQueue {
    get
  }
}
@available(*, deprecated, renamed: "KingfisherError.domain", message: "Use `KingfisherError.domain` instead.")
public let KingfisherErrorDomain: Swift.String
@available(*, unavailable, message: "Use `.invalidHTTPStatusCode` or `isInvalidResponseStatusCode` of `KingfisherError` instead for the status code.")
public let KingfisherErrorStatusCodeKey: Swift.String
extension Collection where Self.Element == IMMap.KingfisherOptionsInfoItem {
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `targetCache` instead.")
  public var targetCache: IMMap.ImageCache? {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `originalCache` instead.")
  public var originalCache: IMMap.ImageCache? {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `downloader` instead.")
  public var downloader: IMMap.ImageDownloader? {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `transition` instead.")
  public var transition: IMMap.ImageTransition {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `downloadPriority` instead.")
  public var downloadPriority: Swift.Float {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `forceRefresh` instead.")
  public var forceRefresh: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `fromMemoryCacheOrRefresh` instead.")
  public var fromMemoryCacheOrRefresh: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `forceTransition` instead.")
  public var forceTransition: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `cacheMemoryOnly` instead.")
  public var cacheMemoryOnly: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `waitForCache` instead.")
  public var waitForCache: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `onlyFromCache` instead.")
  public var onlyFromCache: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `backgroundDecode` instead.")
  public var backgroundDecode: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `preloadAllAnimationData` instead.")
  public var preloadAllAnimationData: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `callbackQueue` instead.")
  public var callbackQueue: IMMap.CallbackQueue {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `scaleFactor` instead.")
  public var scaleFactor: CoreGraphics.CGFloat {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `requestModifier` instead.")
  public var modifier: IMMap.ImageDownloadRequestModifier? {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `processor` instead.")
  public var processor: IMMap.ImageProcessor {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `imageModifier` instead.")
  public var imageModifier: IMMap.ImageModifier? {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `cacheSerializer` instead.")
  public var cacheSerializer: IMMap.CacheSerializer {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `keepCurrentImageWhileLoading` instead.")
  public var keepCurrentImageWhileLoading: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `onlyLoadFirstFrame` instead.")
  public var onlyLoadFirstFrame: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `cacheOriginalImage` instead.")
  public var cacheOriginalImage: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `onFailureImage` instead.")
  public var onFailureImage: Swift.Optional<IMMap.KFCrossPlatformImage?> {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `alsoPrefetchToMemory` instead.")
  public var alsoPrefetchToMemory: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `loadDiskFileSynchronously` instead.")
  public var loadDiskFileSynchronously: Swift.Bool {
    get
  }
}
@available(*, deprecated, message: "Use `nil` in KingfisherOptionsInfo to indicate no modifier.")
public struct DefaultImageModifier : IMMap.ImageModifier {
  public static let `default`: IMMap.DefaultImageModifier
  public func modify(_ image: IMMap.KFCrossPlatformImage) -> IMMap.KFCrossPlatformImage
}
@available(*, deprecated, message: "Use `KFCrossPlatformImage` instead.")
public typealias Image = IMMap.KFCrossPlatformImage
@available(*, deprecated, message: "Use `KFCrossPlatformColor` instead.")
public typealias Color = IMMap.KFCrossPlatformColor
@available(*, deprecated, message: "Use `KFCrossPlatformImageView` instead.")
public typealias ImageView = IMMap.KFCrossPlatformImageView
@available(*, deprecated, message: "Use `KFCrossPlatformView` instead.")
public typealias View = IMMap.KFCrossPlatformView
@available(*, deprecated, message: "Use `KFCrossPlatformButton` instead.")
public typealias Button = IMMap.KFCrossPlatformButton
public protocol ControlEventType : IMMap.ObservableType {
  func asControlEvent() -> IMMap.ControlEvent<Self.Element>
}
public struct ControlEvent<PropertyType> : IMMap.ControlEventType {
  public typealias Element = PropertyType
  public init<Ev>(events: Ev) where PropertyType == Ev.Element, Ev : IMMap.ObservableType
  public func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where PropertyType == Observer.Element, Observer : IMMap.ObserverType
  public func asObservable() -> IMMap.Observable<IMMap.ControlEvent<PropertyType>.Element>
  public func asControlEvent() -> IMMap.ControlEvent<IMMap.ControlEvent<PropertyType>.Element>
}
extension ObservableType {
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)? = nil, afterNext: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((Swift.Error) throws -> Swift.Void)? = nil, afterError: ((Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> IMMap.Observable<Self.Element>
}
extension EKAttributes {
  public enum StatusBar {
    public typealias Appearance = (visible: Swift.Bool, style: UIKit.UIStatusBarStyle)
    case ignored
    case hidden
    case dark
    case light
    case inferred
    public var appearance: IMMap.EKAttributes.StatusBar.Appearance {
      get
    }
    public static func statusBar(by appearance: IMMap.EKAttributes.StatusBar.Appearance) -> IMMap.EKAttributes.StatusBar
    public static var currentAppearance: IMMap.EKAttributes.StatusBar.Appearance {
      get
    }
    public static var currentStatusBar: IMMap.EKAttributes.StatusBar {
      get
    }
    public static func == (a: IMMap.EKAttributes.StatusBar, b: IMMap.EKAttributes.StatusBar) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
final public class AsyncSubject<Element> : IMMap.Observable<Element>, IMMap.SubjectType, IMMap.ObserverType {
  public typealias SubjectObserverType = IMMap.AsyncSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  override public init()
  final public func on(_ event: IMMap.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where Element == Observer.Element, Observer : IMMap.ObserverType
  final public func asObserver() -> IMMap.AsyncSubject<Element>
  @objc deinit
  public typealias Observer = IMMap.AsyncSubject<Element>
}
extension Reactive where Base : UIKit.UIBarButtonItem {
  public var isEnabled: IMMap.Binder<Swift.Bool> {
    get
  }
  public var title: IMMap.Binder<Swift.String> {
    get
  }
  public var tap: IMMap.ControlEvent<()> {
    get
  }
}
extension Reactive where Base : UIKit.UIViewController {
  public var title: IMMap.Binder<Swift.String> {
    get
  }
}
extension ObservableType {
  public static func never() -> IMMap.Observable<Self.Element>
}
extension Reactive where Base : UIKit.UISegmentedControl {
  public var selectedSegmentIndex: IMMap.ControlProperty<Swift.Int> {
    get
  }
  public var value: IMMap.ControlProperty<Swift.Int> {
    get
  }
  public func enabledForSegment(at index: Swift.Int) -> IMMap.Binder<Swift.Bool>
  public func titleForSegment(at index: Swift.Int) -> IMMap.Binder<Swift.String?>
  public func imageForSegment(at index: Swift.Int) -> IMMap.Binder<UIKit.UIImage?>
}
public struct Disposables {
}
extension ObservableType where Self.Element : Swift.Equatable {
  public func distinctUntilChanged() -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) throws -> Key) -> IMMap.Observable<Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) throws -> Swift.Bool) -> IMMap.Observable<Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) throws -> K, comparer: @escaping (K, K) throws -> Swift.Bool) -> IMMap.Observable<Self.Element>
}
open class VirtualTimeScheduler<Converter> : IMMap.SchedulerType where Converter : IMMap.VirtualTimeConverterType {
  public typealias VirtualTime = Converter.VirtualTimeUnit
  public typealias VirtualTimeInterval = Converter.VirtualTimeIntervalUnit
  public var now: IMMap.RxTime {
    get
  }
  public var clock: IMMap.VirtualTimeScheduler<Converter>.VirtualTime {
    get
  }
  public init(initialClock: IMMap.VirtualTimeScheduler<Converter>.VirtualTime, converter: Converter)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  public func scheduleRelative<StateType>(_ state: StateType, dueTime: IMMap.RxTimeInterval, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  public func scheduleRelativeVirtual<StateType>(_ state: StateType, dueTime: IMMap.VirtualTimeScheduler<Converter>.VirtualTimeInterval, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  public func scheduleAbsoluteVirtual<StateType>(_ state: StateType, time: IMMap.VirtualTimeScheduler<Converter>.VirtualTime, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  open func adjustScheduledTime(_ time: IMMap.VirtualTimeScheduler<Converter>.VirtualTime) -> IMMap.VirtualTimeScheduler<Converter>.VirtualTime
  public func start()
  public func advanceTo(_ virtualTime: IMMap.VirtualTimeScheduler<Converter>.VirtualTime)
  public func sleep(_ virtualInterval: IMMap.VirtualTimeScheduler<Converter>.VirtualTimeInterval)
  public func stop()
  @objc deinit
}
extension VirtualTimeScheduler : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum MaybeTrait {
}
public typealias Maybe<Element> = IMMap.PrimitiveSequence<IMMap.MaybeTrait, Element>
public enum MaybeEvent<Element> {
  case success(Element)
  case error(Swift.Error)
  case completed
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public typealias MaybeObserver = (IMMap.MaybeEvent<Self.Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.MaybeObserver) -> IMMap.Disposable) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
  public func subscribe(_ observer: @escaping (IMMap.MaybeEvent<Self.Element>) -> Swift.Void) -> IMMap.Disposable
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onError: ((Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil) -> IMMap.Disposable
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public static func just(_ element: Self.Element) -> IMMap.Maybe<Self.Element>
  public static func just(_ element: Self.Element, scheduler: IMMap.ImmediateSchedulerType) -> IMMap.Maybe<Self.Element>
  public static func error(_ error: Swift.Error) -> IMMap.Maybe<Self.Element>
  public static func never() -> IMMap.Maybe<Self.Element>
  public static func empty() -> IMMap.Maybe<Self.Element>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.MaybeTrait {
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)? = nil, afterNext: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((Swift.Error) throws -> Swift.Void)? = nil, afterError: ((Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> IMMap.Maybe<Self.Element>
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> IMMap.Maybe<Self.Element>
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> IMMap.Maybe<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> IMMap.Maybe<Result>
  public func flatMap<Result>(_ selector: @escaping (Self.Element) throws -> IMMap.Maybe<Result>) -> IMMap.Maybe<Result>
  public func ifEmpty(default: Self.Element) -> IMMap.Single<Self.Element>
  public func ifEmpty(switchTo other: IMMap.Maybe<Self.Element>) -> IMMap.Maybe<Self.Element>
  public func ifEmpty(switchTo other: IMMap.Single<Self.Element>) -> IMMap.Single<Self.Element>
  public func catchErrorJustReturn(_ element: Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension EKAttributes {
  public enum RoundCorners {
    case none
    case all(radius: CoreGraphics.CGFloat)
    case top(radius: CoreGraphics.CGFloat)
    case bottom(radius: CoreGraphics.CGFloat)
  }
  public enum Border {
    case none
    case value(color: UIKit.UIColor, width: CoreGraphics.CGFloat)
  }
}
extension ObservableType {
  public func catchError(_ handler: @escaping (Swift.Error) throws -> IMMap.Observable<Self.Element>) -> IMMap.Observable<Self.Element>
  public func catchErrorJustReturn(_ element: Self.Element) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public static func catchError<Sequence>(_ sequence: Sequence) -> IMMap.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func retry() -> IMMap.Observable<Self.Element>
  public func retry(_ maxAttemptCount: Swift.Int) -> IMMap.Observable<Self.Element>
}
public enum RxCocoaURLError : Swift.Error {
  case unknown
  case nonHTTPResponse(response: Foundation.URLResponse)
  case httpRequestFailed(response: Foundation.HTTPURLResponse, data: Foundation.Data?)
  case deserializationError(error: Swift.Error)
}
extension RxCocoaURLError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Reactive where Base : Foundation.URLSession {
  public func response(request: Foundation.URLRequest) -> IMMap.Observable<(response: Foundation.HTTPURLResponse, data: Foundation.Data)>
  public func data(request: Foundation.URLRequest) -> IMMap.Observable<Foundation.Data>
  public func json(request: Foundation.URLRequest, options: Foundation.JSONSerialization.ReadingOptions = []) -> IMMap.Observable<Any>
  public func json(url: Foundation.URL) -> IMMap.Observable<Any>
}
public enum MemoryStorage {
  public class Backend<T> where T : IMMap.CacheCostCalculable {
    public var config: IMMap.MemoryStorage.Config {
      get
      set
    }
    public init(config: IMMap.MemoryStorage.Config)
    @objc deinit
  }
}
extension MemoryStorage {
  public struct Config {
    public var totalCostLimit: Swift.Int
    public var countLimit: Swift.Int
    public var expiration: IMMap.StorageExpiration
    public let cleanInterval: Foundation.TimeInterval
    public init(totalCostLimit: Swift.Int, cleanInterval: Foundation.TimeInterval = 120)
  }
}
public struct SharedSequence<SharingStrategy, Element> : IMMap.SharedSequenceConvertibleType where SharingStrategy : IMMap.SharingStrategyProtocol {
  public func asObservable() -> IMMap.Observable<Element>
  public func asSharedSequence() -> IMMap.SharedSequence<SharingStrategy, Element>
}
public protocol SharingStrategyProtocol {
  static var scheduler: IMMap.SchedulerType { get }
  static func share<Element>(_ source: IMMap.Observable<Element>) -> IMMap.Observable<Element>
}
public protocol SharedSequenceConvertibleType : IMMap.ObservableConvertibleType {
  associatedtype SharingStrategy : IMMap.SharingStrategyProtocol
  func asSharedSequence() -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func asObservable() -> IMMap.Observable<Self.Element>
}
extension SharedSequence {
  public static func empty() -> IMMap.SharedSequence<SharingStrategy, Element>
  public static func never() -> IMMap.SharedSequence<SharingStrategy, Element>
  public static func just(_ element: Element) -> IMMap.SharedSequence<SharingStrategy, Element>
  public static func deferred(_ observableFactory: @escaping () -> IMMap.SharedSequence<SharingStrategy, Element>) -> IMMap.SharedSequence<SharingStrategy, Element>
  public static func of(_ elements: Element...) -> IMMap.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence {
  public static func from(_ array: [Element]) -> IMMap.SharedSequence<SharingStrategy, Element>
  public static func from<Sequence>(_ sequence: Sequence) -> IMMap.SharedSequence<SharingStrategy, Element> where Element == Sequence.Element, Sequence : Swift.Sequence
  public static func from(optional: Element?) -> IMMap.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence where Element : Swift.FixedWidthInteger {
  public static func interval(_ period: IMMap.RxTimeInterval) -> IMMap.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence where Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: IMMap.RxTimeInterval, period: IMMap.RxTimeInterval) -> IMMap.SharedSequence<SharingStrategy, Element>
}
public protocol ReuseIdentifierType : IMMap.IdentifierType {
  associatedtype ReusableType
}
public struct ReuseIdentifier<Reusable> : IMMap.ReuseIdentifierType {
  public typealias ReusableType = Reusable
  public let identifier: Swift.String
  public init(identifier: Swift.String)
}
@objc public protocol IMMapViewControllerDelegate : ObjectiveC.NSObjectProtocol {
  @objc func imMapViewControllerWillClose(_ imMapViewController: IMMap.IMMapViewController)
  @objc func imMapViewController(_ imMapViewController: IMMap.IMMapViewController, willShare link: Swift.String)
}
@objc public class IMMapViewController : UIKit.UIViewController {
  @objc public var delegate: IMMap.IMMapViewControllerDelegate?
  @objc public var isAlwaysOpenSearchView: Swift.Bool
  @objc public class func mapViewController() -> IMMap.IMMapViewController?
  @objc public class func mapViewController(withMallId mallId: Swift.Int32) -> IMMap.IMMapViewController?
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @objc override dynamic public func viewDidLayoutSubviews()
  @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @objc deinit
  @objc public func checkToOpenAirportList()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension IMMapViewController : MapKit.MKMapViewDelegate {
  @objc dynamic public func mapView(_ mapView: MapKit.MKMapView, regionDidChangeAnimated animated: Swift.Bool)
  @objc dynamic public func mapView(_ mapView: MapKit.MKMapView, rendererFor overlay: MapKit.MKOverlay) -> MapKit.MKOverlayRenderer
  @objc dynamic public func mapView(_ mapView: MapKit.MKMapView, viewFor annotation: MapKit.MKAnnotation) -> MapKit.MKAnnotationView?
  @objc dynamic public func mapView(_ mapView: MapKit.MKMapView, didSelect view: MapKit.MKAnnotationView)
  @objc dynamic public func mapView(_ mapView: MapKit.MKMapView, didDeselect view: MapKit.MKAnnotationView)
}
extension IMMapViewController : UIKit.UITableViewDelegate {
  @objc dynamic public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
}
extension IMMapViewController : UIKit.UITextFieldDelegate {
  @objc dynamic public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
}
extension IMMapViewController : CoreData.NSFetchedResultsControllerDelegate {
  @objc dynamic public func controllerDidChangeContent(_ controller: CoreData.NSFetchedResultsController<CoreData.NSFetchRequestResult>)
}
extension Reactive where Base : UIKit.UIButton {
  public var tap: IMMap.ControlEvent<Swift.Void> {
    get
  }
}
extension Reactive where Base : UIKit.UIButton {
  public func title(for controlState: UIKit.UIControl.State = []) -> IMMap.Binder<Swift.String?>
  public func image(for controlState: UIKit.UIControl.State = []) -> IMMap.Binder<UIKit.UIImage?>
  public func backgroundImage(for controlState: UIKit.UIControl.State = []) -> IMMap.Binder<UIKit.UIImage?>
}
extension Reactive where Base : UIKit.UIButton {
  public func attributedTitle(for controlState: UIKit.UIControl.State = []) -> IMMap.Binder<Foundation.NSAttributedString?>
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: IMMap.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> IMMap.Observable<Element?>
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: IMMap.KeyValueObservingOptions = [.new, .initial]) -> IMMap.Observable<Element?>
}
extension Reactive where Base : AnyObject {
  public var deallocated: IMMap.Observable<Swift.Void> {
    get
  }
  public func sentMessage(_ selector: ObjectiveC.Selector) -> IMMap.Observable<[Any]>
  public func methodInvoked(_ selector: ObjectiveC.Selector) -> IMMap.Observable<[Any]>
  public var deallocating: IMMap.Observable<()> {
    get
  }
}
extension ObservableType {
  public func takeWhile(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> IMMap.Observable<Self.Element>
}
public class OperationQueueScheduler : IMMap.ImmediateSchedulerType {
  final public let operationQueue: Foundation.OperationQueue
  final public let queuePriority: Foundation.Operation.QueuePriority
  public init(operationQueue: Foundation.OperationQueue, queuePriority: Foundation.Operation.QueuePriority = .normal)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  @objc deinit
}
public protocol NibResourceType {
  var bundle: Foundation.Bundle { get }
  var name: Swift.String { get }
}
public struct Reactive<Base> {
  public let base: Base
  public init(_ base: Base)
}
public protocol ReactiveCompatible {
  associatedtype ReactiveBase
  @available(*, deprecated, renamed: "ReactiveBase")
  typealias CompatibleType = Self.ReactiveBase
  static var rx: IMMap.Reactive<Self.ReactiveBase>.Type { get set }
  var rx: IMMap.Reactive<Self.ReactiveBase> { get set }
}
extension ReactiveCompatible {
  public static var rx: IMMap.Reactive<Self>.Type {
    get
    set
  }
  public var rx: IMMap.Reactive<Self> {
    get
    set
  }
}
extension NSObject : IMMap.ReactiveCompatible {
  public typealias ReactiveBase = ObjectiveC.NSObject
}
extension ObservableType {
  public func throttle(_ dueTime: IMMap.RxTimeInterval, latest: Swift.Bool = true, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
public typealias RxAbstractInteger = Swift.FixedWidthInteger
extension ObservableType {
  public func enumerated() -> IMMap.Observable<(index: Swift.Int, element: Self.Element)>
}
public typealias KingfisherOptionsInfo = [IMMap.KingfisherOptionsInfoItem]
public enum KingfisherOptionsInfoItem {
  case targetCache(IMMap.ImageCache)
  case originalCache(IMMap.ImageCache)
  case downloader(IMMap.ImageDownloader)
  case transition(IMMap.ImageTransition)
  case downloadPriority(Swift.Float)
  case forceRefresh
  case fromMemoryCacheOrRefresh
  case forceTransition
  case cacheMemoryOnly
  case waitForCache
  case onlyFromCache
  case backgroundDecode
  @available(*, deprecated, message: "Use `.callbackQueue(CallbackQueue)` instead.")
  case callbackDispatchQueue(Dispatch.DispatchQueue?)
  case callbackQueue(IMMap.CallbackQueue)
  case scaleFactor(CoreGraphics.CGFloat)
  case preloadAllAnimationData
  case requestModifier(IMMap.ImageDownloadRequestModifier)
  case redirectHandler(IMMap.ImageDownloadRedirectHandler)
  case processor(IMMap.ImageProcessor)
  case cacheSerializer(IMMap.CacheSerializer)
  case imageModifier(IMMap.ImageModifier)
  case keepCurrentImageWhileLoading
  case onlyLoadFirstFrame
  case cacheOriginalImage
  case onFailureImage(IMMap.KFCrossPlatformImage?)
  case alsoPrefetchToMemory
  case loadDiskFileSynchronously
  case memoryCacheExpiration(IMMap.StorageExpiration)
  case memoryCacheAccessExtendingExpiration(IMMap.ExpirationExtending)
  case diskCacheExpiration(IMMap.StorageExpiration)
  case diskCacheAccessExtendingExpiration(IMMap.ExpirationExtending)
  case processingQueue(IMMap.CallbackQueue)
  case progressiveJPEG(IMMap.ImageProgressive)
  case alternativeSources([IMMap.Source])
  case retryStrategy(IMMap.RetryStrategy)
}
public struct KingfisherParsedOptionsInfo {
  public var targetCache: IMMap.ImageCache?
  public var originalCache: IMMap.ImageCache?
  public var downloader: IMMap.ImageDownloader?
  public var transition: IMMap.ImageTransition
  public var downloadPriority: Swift.Float
  public var forceRefresh: Swift.Bool
  public var fromMemoryCacheOrRefresh: Swift.Bool
  public var forceTransition: Swift.Bool
  public var cacheMemoryOnly: Swift.Bool
  public var waitForCache: Swift.Bool
  public var onlyFromCache: Swift.Bool
  public var backgroundDecode: Swift.Bool
  public var preloadAllAnimationData: Swift.Bool
  public var callbackQueue: IMMap.CallbackQueue
  public var scaleFactor: CoreGraphics.CGFloat
  public var requestModifier: IMMap.ImageDownloadRequestModifier?
  public var redirectHandler: IMMap.ImageDownloadRedirectHandler?
  public var processor: IMMap.ImageProcessor
  public var imageModifier: IMMap.ImageModifier?
  public var cacheSerializer: IMMap.CacheSerializer
  public var keepCurrentImageWhileLoading: Swift.Bool
  public var onlyLoadFirstFrame: Swift.Bool
  public var cacheOriginalImage: Swift.Bool
  public var onFailureImage: Swift.Optional<IMMap.KFCrossPlatformImage?>
  public var alsoPrefetchToMemory: Swift.Bool
  public var loadDiskFileSynchronously: Swift.Bool
  public var memoryCacheExpiration: IMMap.StorageExpiration?
  public var memoryCacheAccessExtendingExpiration: IMMap.ExpirationExtending
  public var diskCacheExpiration: IMMap.StorageExpiration?
  public var diskCacheAccessExtendingExpiration: IMMap.ExpirationExtending
  public var processingQueue: IMMap.CallbackQueue?
  public var progressiveJPEG: IMMap.ImageProgressive?
  public var alternativeSources: [IMMap.Source]?
  public var retryStrategy: IMMap.RetryStrategy?
  public init(_ info: IMMap.KingfisherOptionsInfo?)
}
extension ObservableType {
  public func debounce(_ dueTime: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableConvertibleType {
  public func asSignal(onErrorJustReturn: Self.Element) -> IMMap.Signal<Self.Element>
  public func asSignal(onErrorSignalWith: IMMap.Signal<Self.Element>) -> IMMap.Signal<Self.Element>
  public func asSignal(onErrorRecover: @escaping (Swift.Error) -> IMMap.Signal<Self.Element>) -> IMMap.Signal<Self.Element>
}
extension EKAttributes {
  public enum PopBehavior {
    case overridden
    case animated(animation: IMMap.EKAttributes.Animation)
    public var isOverriden: Swift.Bool {
      get
    }
  }
}
extension SharedSequenceConvertibleType {
  public func map<Result>(_ selector: @escaping (Self.Element) -> Result) -> IMMap.SharedSequence<Self.SharingStrategy, Result>
}
extension SharedSequenceConvertibleType {
  public func compactMap<Result>(_ selector: @escaping (Self.Element) -> Result?) -> IMMap.SharedSequence<Self.SharingStrategy, Result>
}
extension SharedSequenceConvertibleType {
  public func filter(_ predicate: @escaping (Self.Element) -> Swift.Bool) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType where Self.Element : IMMap.SharedSequenceConvertibleType {
  public func switchLatest() -> IMMap.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension SharedSequenceConvertibleType {
  public func flatMapLatest<Sharing, Result>(_ selector: @escaping (Self.Element) -> IMMap.SharedSequence<Sharing, Result>) -> IMMap.SharedSequence<Sharing, Result> where Sharing : IMMap.SharingStrategyProtocol
}
extension SharedSequenceConvertibleType {
  public func flatMapFirst<Sharing, Result>(_ selector: @escaping (Self.Element) -> IMMap.SharedSequence<Sharing, Result>) -> IMMap.SharedSequence<Sharing, Result> where Sharing : IMMap.SharingStrategyProtocol
}
extension SharedSequenceConvertibleType {
  public func `do`(onNext: ((Self.Element) -> Swift.Void)? = nil, afterNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, afterCompleted: (() -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType where Self.Element : Swift.Equatable {
  public func distinctUntilChanged() -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) -> Key) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) -> Swift.Bool) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) -> K, comparer: @escaping (K, K) -> Swift.Bool) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func flatMap<Sharing, Result>(_ selector: @escaping (Self.Element) -> IMMap.SharedSequence<Sharing, Result>) -> IMMap.SharedSequence<Sharing, Result> where Sharing : IMMap.SharingStrategyProtocol
}
extension SharedSequenceConvertibleType {
  public static func merge<Collection>(_ sources: Collection) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element> where Collection : Swift.Collection, Collection.Element == IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: [IMMap.SharedSequence<Self.SharingStrategy, Self.Element>]) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: IMMap.SharedSequence<Self.SharingStrategy, Self.Element>...) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType where Self.Element : IMMap.SharedSequenceConvertibleType {
  public func merge() -> IMMap.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
  public func merge(maxConcurrent: Swift.Int) -> IMMap.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension SharedSequenceConvertibleType {
  public func throttle(_ dueTime: IMMap.RxTimeInterval, latest: Swift.Bool = true) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
  public func debounce(_ dueTime: IMMap.RxTimeInterval) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.Element) -> A) -> IMMap.SharedSequence<Self.SharingStrategy, A>
}
extension SharedSequence {
  public static func concat<Sequence>(_ sequence: Sequence) -> IMMap.SharedSequence<SharingStrategy, Element> where Sequence : Swift.Sequence, Sequence.Element == IMMap.SharedSequence<SharingStrategy, Element>
  public static func concat<Collection>(_ collection: Collection) -> IMMap.SharedSequence<SharingStrategy, Element> where Collection : Swift.Collection, Collection.Element == IMMap.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence {
  public static func zip<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> IMMap.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == IMMap.SharedSequence<SharingStrategy, Element>
  public static func zip<Collection>(_ collection: Collection) -> IMMap.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == IMMap.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence {
  public static func combineLatest<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> IMMap.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == IMMap.SharedSequence<SharingStrategy, Element>
  public static func combineLatest<Collection>(_ collection: Collection) -> IMMap.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == IMMap.SharedSequence<SharingStrategy, Element>
}
extension SharedSequenceConvertibleType {
  public func withLatestFrom<SecondO, ResultType>(_ second: SecondO, resultSelector: @escaping (Self.Element, SecondO.Element) -> ResultType) -> IMMap.SharedSequence<Self.SharingStrategy, ResultType> where SecondO : IMMap.SharedSequenceConvertibleType, Self.SharingStrategy == SecondO.SharingStrategy
  public func withLatestFrom<SecondO>(_ second: SecondO) -> IMMap.SharedSequence<Self.SharingStrategy, SecondO.Element> where SecondO : IMMap.SharedSequenceConvertibleType
}
extension SharedSequenceConvertibleType {
  public func skip(_ count: Swift.Int) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func startWith(_ element: Self.Element) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func delay(_ dueTime: IMMap.RxTimeInterval) -> IMMap.SharedSequence<Self.SharingStrategy, Self.Element>
}
public protocol ImageDataProvider {
  var cacheKey: Swift.String { get }
  func data(handler: @escaping (IMMap.KFResult<Foundation.Data, Swift.Error>) -> Swift.Void)
  var contentURL: Foundation.URL? { get }
}
extension ImageDataProvider {
  public var contentURL: Foundation.URL? {
    get
  }
}
public struct LocalFileImageDataProvider : IMMap.ImageDataProvider {
  public let fileURL: Foundation.URL
  public init(fileURL: Foundation.URL, cacheKey: Swift.String? = nil)
  public var cacheKey: Swift.String
  public func data(handler: (IMMap.KFResult<Foundation.Data, Swift.Error>) -> Swift.Void)
  public var contentURL: Foundation.URL? {
    get
  }
}
public struct Base64ImageDataProvider : IMMap.ImageDataProvider {
  public let base64String: Swift.String
  public init(base64String: Swift.String, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: (IMMap.KFResult<Foundation.Data, Swift.Error>) -> Swift.Void)
}
public struct RawImageDataProvider : IMMap.ImageDataProvider {
  public let data: Foundation.Data
  public init(data: Foundation.Data, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: @escaping (IMMap.KFResult<Foundation.Data, Swift.Error>) -> Swift.Void)
}
extension ObservableType {
  public func scan<A>(into seed: A, accumulator: @escaping (inout A, Self.Element) throws -> Swift.Void) -> IMMap.Observable<A>
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A) -> IMMap.Observable<A>
}
@objc final public class EKNotificationMessageView : IMMap.EKSimpleMessageView {
  public init(with message: IMMap.EKNotificationMessage)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc deinit
}
extension EKAttributes {
  public enum Scroll {
    public struct PullbackAnimation {
      public var duration: Foundation.TimeInterval
      public var damping: CoreGraphics.CGFloat
      public var initialSpringVelocity: CoreGraphics.CGFloat
      public init(duration: Foundation.TimeInterval, damping: CoreGraphics.CGFloat, initialSpringVelocity: CoreGraphics.CGFloat)
      public static var jolt: IMMap.EKAttributes.Scroll.PullbackAnimation {
        get
      }
      public static var easeOut: IMMap.EKAttributes.Scroll.PullbackAnimation {
        get
      }
    }
    case disabled
    case edgeCrossingDisabled(swipeable: Swift.Bool)
    case enabled(swipeable: Swift.Bool, pullbackAnimation: IMMap.EKAttributes.Scroll.PullbackAnimation)
  }
}
final public class ConcurrentMainScheduler : IMMap.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  final public var now: Foundation.Date {
    get
  }
  public static let instance: IMMap.ConcurrentMainScheduler
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: IMMap.RxTimeInterval, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  final public func schedulePeriodic<StateType>(_ state: StateType, startAfter: IMMap.RxTimeInterval, period: IMMap.RxTimeInterval, action: @escaping (StateType) -> StateType) -> IMMap.Disposable
  @objc deinit
}
public protocol IdentifierType : Swift.CustomStringConvertible {
  var identifier: Swift.String { get }
}
extension IdentifierType {
  public var description: Swift.String {
    get
  }
}
extension Disposables {
  public static func create(_ disposable1: IMMap.Disposable, _ disposable2: IMMap.Disposable) -> IMMap.Cancelable
}
public protocol StringResourceType {
  var key: Swift.String { get }
  var tableName: Swift.String { get }
  var bundle: Foundation.Bundle { get }
  var locales: [Swift.String] { get }
  var comment: Swift.String? { get }
}
public struct StringResource : IMMap.StringResourceType {
  public let key: Swift.String
  public let tableName: Swift.String
  public let bundle: Foundation.Bundle
  public let locales: [Swift.String]
  public let comment: Swift.String?
  public init(key: Swift.String, tableName: Swift.String, bundle: Foundation.Bundle, locales: [Swift.String], comment: Swift.String?)
}
open class RxTableViewDelegateProxy : IMMap.RxScrollViewDelegateProxy, UIKit.UITableViewDelegate {
  weak public var tableView: UIKit.UITableView? {
    get
    }
  public init(tableView: UIKit.UITableView)
  override public init(scrollView: IMMap.RxScrollViewDelegateProxy.ParentObject)
  @objc deinit
}
public protocol ImageModifier {
  func modify(_ image: IMMap.KFCrossPlatformImage) -> IMMap.KFCrossPlatformImage
}
public struct AnyImageModifier : IMMap.ImageModifier {
  public init(modify: @escaping (IMMap.KFCrossPlatformImage) throws -> IMMap.KFCrossPlatformImage)
  public func modify(_ image: IMMap.KFCrossPlatformImage) -> IMMap.KFCrossPlatformImage
}
public struct RenderingModeImageModifier : IMMap.ImageModifier {
  public let renderingMode: UIKit.UIImage.RenderingMode
  public init(renderingMode: UIKit.UIImage.RenderingMode = .automatic)
  public func modify(_ image: IMMap.KFCrossPlatformImage) -> IMMap.KFCrossPlatformImage
}
public struct FlipsForRightToLeftLayoutDirectionImageModifier : IMMap.ImageModifier {
  public init()
  public func modify(_ image: IMMap.KFCrossPlatformImage) -> IMMap.KFCrossPlatformImage
}
public struct AlignmentRectInsetsImageModifier : IMMap.ImageModifier {
  public let alignmentInsets: UIKit.UIEdgeInsets
  public init(alignmentInsets: UIKit.UIEdgeInsets)
  public func modify(_ image: IMMap.KFCrossPlatformImage) -> IMMap.KFCrossPlatformImage
}
public protocol FileResourceType {
  var bundle: Foundation.Bundle { get }
  var name: Swift.String { get }
  var pathExtension: Swift.String { get }
}
extension FileResourceType {
  public var fullName: Swift.String {
    get
  }
  public func path() -> Swift.String?
  public func url() -> Foundation.URL?
}
public struct FileResource : IMMap.FileResourceType {
  public let bundle: Foundation.Bundle
  public let name: Swift.String
  public let pathExtension: Swift.String
  public init(bundle: Foundation.Bundle, name: Swift.String, pathExtension: Swift.String)
}
public struct Timeline {
  public let requestStartTime: CoreFoundation.CFAbsoluteTime
  public let initialResponseTime: CoreFoundation.CFAbsoluteTime
  public let requestCompletedTime: CoreFoundation.CFAbsoluteTime
  public let serializationCompletedTime: CoreFoundation.CFAbsoluteTime
  public let latency: Foundation.TimeInterval
  public let requestDuration: Foundation.TimeInterval
  public let serializationDuration: Foundation.TimeInterval
  public let totalDuration: Foundation.TimeInterval
  public init(requestStartTime: CoreFoundation.CFAbsoluteTime = 0.0, initialResponseTime: CoreFoundation.CFAbsoluteTime = 0.0, requestCompletedTime: CoreFoundation.CFAbsoluteTime = 0.0, serializationCompletedTime: CoreFoundation.CFAbsoluteTime = 0.0)
}
extension Timeline : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Timeline : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension UICollectionView : IMMap.HasDataSource {
  public typealias DataSource = UIKit.UICollectionViewDataSource
}
open class RxCollectionViewDataSourceProxy : IMMap.DelegateProxy<UIKit.UICollectionView, UIKit.UICollectionViewDataSource>, IMMap.DelegateProxyType, UIKit.UICollectionViewDataSource {
  weak public var collectionView: UIKit.UICollectionView? {
    get
    }
  public init(collectionView: IMMap.RxCollectionViewDataSourceProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  override open func setForwardToDelegate(_ forwardToDelegate: UIKit.UICollectionViewDataSource?, retainDelegate: Swift.Bool)
  override public init<Proxy>(parentObject: UIKit.UICollectionView, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UICollectionView, UIKit.UICollectionViewDataSource>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UICollectionViewDataSource, Proxy.ParentObject == UIKit.UICollectionView
  @objc deinit
}
public protocol ObservableType : IMMap.ObservableConvertibleType {
  func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where Observer : IMMap.ObserverType, Self.Element == Observer.Element
}
extension ObservableType {
  public func asObservable() -> IMMap.Observable<Self.Element>
}
public protocol RxCollectionViewDataSourceType {
  associatedtype Element
  func collectionView(_ collectionView: UIKit.UICollectionView, observedEvent: IMMap.Event<Self.Element>)
}
public struct NoUrlForResourceError : Swift.Error {
}
extension Data {
  public init(resource: IMMap.FileResourceType) throws
}
extension Reactive where Base : UIKit.UINavigationController {
  public typealias ShowEvent = (viewController: UIKit.UIViewController, animated: Swift.Bool)
  public var delegate: IMMap.DelegateProxy<UIKit.UINavigationController, UIKit.UINavigationControllerDelegate> {
    get
  }
  public var willShow: IMMap.ControlEvent<IMMap.Reactive<Base>.ShowEvent> {
    get
  }
  public var didShow: IMMap.ControlEvent<IMMap.Reactive<Base>.ShowEvent> {
    get
  }
}
final public class BehaviorRelay<Element> : IMMap.ObservableType {
  final public func accept(_ event: Element)
  final public var value: Element {
    get
  }
  public init(value: Element)
  final public func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where Element == Observer.Element, Observer : IMMap.ObserverType
  final public func asObservable() -> IMMap.Observable<Element>
  @objc deinit
}
extension CGRect : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreGraphics.CGRect.KVOType)
}
extension CGPoint : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreGraphics.CGPoint.KVOType)
}
extension CGSize : IMMap.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreGraphics.CGSize.KVOType)
}
extension UIViewController {
  convenience public init(nib: IMMap.NibResourceType)
}
public enum KFResult<Success, Failure> {
  case success(Success)
  case failure(Failure)
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> IMMap.KFResult<NewSuccess, Failure>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> IMMap.KFResult<Success, NewFailure>
  public func flatMap<NewSuccess>(_ transform: (Success) -> IMMap.KFResult<NewSuccess, Failure>) -> IMMap.KFResult<NewSuccess, Failure>
  public func flatMapError<NewFailure>(_ transform: (Failure) -> IMMap.KFResult<Success, NewFailure>) -> IMMap.KFResult<Success, NewFailure>
}
extension KFResult where Failure : Swift.Error {
  public func get() throws -> Success
  @available(*, deprecated, message: "This method will be removed soon. Use `get() throws -> Success` instead.")
  public func unwrapped() throws -> Success
}
extension KFResult where Failure == Swift.Error {
  @_transparent public init(catching body: () throws -> Success) {
        do {
            self = .success(try body())
        } catch {
            self = .failure(error)
        }
    }
}
extension KFResult : Swift.Equatable where Success : Swift.Equatable, Failure : Swift.Equatable {
  public static func == (a: IMMap.KFResult<Success, Failure>, b: IMMap.KFResult<Success, Failure>) -> Swift.Bool
}
extension KFResult : Swift.Hashable where Success : Swift.Hashable, Failure : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension KFResult : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension EKAttributes {
  public enum Position {
    case top
    case bottom
    case center
    public var isTop: Swift.Bool {
      get
    }
    public var isCenter: Swift.Bool {
      get
    }
    public var isBottom: Swift.Bool {
      get
    }
    public static func == (a: IMMap.EKAttributes.Position, b: IMMap.EKAttributes.Position) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public enum Event<Element> {
  case next(Element)
  case error(Swift.Error)
  case completed
}
extension Event : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Event {
  public var isStopEvent: Swift.Bool {
    get
  }
  public var element: Element? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public var isCompleted: Swift.Bool {
    get
  }
}
extension Event {
  public func map<Result>(_ transform: (Element) throws -> Result) -> IMMap.Event<Result>
}
public protocol EventConvertible {
  associatedtype Element
  @available(*, deprecated, renamed: "Element")
  typealias ElementType = Self.Element
  var event: IMMap.Event<Self.Element> { get }
}
extension Event : IMMap.EventConvertible {
  public var event: IMMap.Event<Element> {
    get
  }
}
extension Reactive where Base : UIKit.UIScrollView {
  public typealias EndZoomEvent = (view: UIKit.UIView?, scale: CoreGraphics.CGFloat)
  public typealias WillEndDraggingEvent = (velocity: CoreGraphics.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreGraphics.CGPoint>)
  public var delegate: IMMap.DelegateProxy<UIKit.UIScrollView, UIKit.UIScrollViewDelegate> {
    get
  }
  public var contentOffset: IMMap.ControlProperty<CoreGraphics.CGPoint> {
    get
  }
  public var isScrollEnabled: IMMap.Binder<Swift.Bool> {
    get
  }
  public var didScroll: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var willBeginDecelerating: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var didEndDecelerating: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var willBeginDragging: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var willEndDragging: IMMap.ControlEvent<IMMap.Reactive<Base>.WillEndDraggingEvent> {
    get
  }
  public var didEndDragging: IMMap.ControlEvent<Swift.Bool> {
    get
  }
  public var didZoom: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var didScrollToTop: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var didEndScrollingAnimation: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var willBeginZooming: IMMap.ControlEvent<UIKit.UIView?> {
    get
  }
  public var didEndZooming: IMMap.ControlEvent<IMMap.Reactive<Base>.EndZoomEvent> {
    get
  }
  public func setDelegate(_ delegate: UIKit.UIScrollViewDelegate) -> IMMap.Disposable
}
@available(iOS 10.0, tvOS 10.0, *)
extension UITableView : IMMap.HasPrefetchDataSource {
  public typealias PrefetchDataSource = UIKit.UITableViewDataSourcePrefetching
}
@available(iOS 10.0, tvOS 10.0, *)
open class RxTableViewDataSourcePrefetchingProxy : IMMap.DelegateProxy<UIKit.UITableView, UIKit.UITableViewDataSourcePrefetching>, IMMap.DelegateProxyType, UIKit.UITableViewDataSourcePrefetching {
  weak public var tableView: UIKit.UITableView? {
    get
    }
  public init(tableView: IMMap.RxTableViewDataSourcePrefetchingProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc public func tableView(_ tableView: UIKit.UITableView, prefetchRowsAt indexPaths: [Foundation.IndexPath])
  override open func setForwardToDelegate(_ forwardToDelegate: UIKit.UITableViewDataSourcePrefetching?, retainDelegate: Swift.Bool)
  @objc deinit
  override public init<Proxy>(parentObject: UIKit.UITableView, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UITableView, UIKit.UITableViewDataSourcePrefetching>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UITableViewDataSourcePrefetching, Proxy.ParentObject == UIKit.UITableView
}
public class SessionDataTask {
  public typealias CancelToken = Swift.Int
  public var mutableData: Foundation.Data {
    get
    }
  final public let task: Foundation.URLSessionDataTask
  @objc deinit
}
extension ObservableType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> IMMap.Observable<Self.Element>
}
open class ServerTrustPolicyManager {
  final public let policies: [Swift.String : IMMap.ServerTrustPolicy]
  public init(policies: [Swift.String : IMMap.ServerTrustPolicy])
  open func serverTrustPolicy(forHost host: Swift.String) -> IMMap.ServerTrustPolicy?
  @objc deinit
}
public enum ServerTrustPolicy {
  case performDefaultEvaluation(validateHost: Swift.Bool)
  case performRevokedEvaluation(validateHost: Swift.Bool, revocationFlags: CoreFoundation.CFOptionFlags)
  case pinCertificates(certificates: [Security.SecCertificate], validateCertificateChain: Swift.Bool, validateHost: Swift.Bool)
  case pinPublicKeys(publicKeys: [Security.SecKey], validateCertificateChain: Swift.Bool, validateHost: Swift.Bool)
  case disableEvaluation
  case customEvaluation((Security.SecTrust, Swift.String) -> Swift.Bool)
  public static func certificates(in bundle: Foundation.Bundle = Bundle.main) -> [Security.SecCertificate]
  public static func publicKeys(in bundle: Foundation.Bundle = Bundle.main) -> [Security.SecKey]
  public func evaluate(_ serverTrust: Security.SecTrust, forHost host: Swift.String) -> Swift.Bool
}
extension Reactive where Base : UIKit.UITableView {
  public func items<Sequence, Source>(_ source: Source) -> (@escaping (UIKit.UITableView, Swift.Int, Sequence.Element) -> UIKit.UITableViewCell) -> IMMap.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : IMMap.ObservableType
  public func items<Sequence, Cell, Source>(cellIdentifier: Swift.String, cellType: Cell.Type = Cell.self) -> (Source) -> (@escaping (Swift.Int, Sequence.Element, Cell) -> Swift.Void) -> IMMap.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Cell : UIKit.UITableViewCell, Source : IMMap.ObservableType
  public func items<DataSource, Source>(dataSource: DataSource) -> (Source) -> IMMap.Disposable where DataSource : IMMap.RxTableViewDataSourceType, DataSource : UIKit.UITableViewDataSource, Source : IMMap.ObservableType, DataSource.Element == Source.Element
}
extension Reactive where Base : UIKit.UITableView {
  public var dataSource: IMMap.DelegateProxy<UIKit.UITableView, UIKit.UITableViewDataSource> {
    get
  }
  public func setDataSource(_ dataSource: UIKit.UITableViewDataSource) -> IMMap.Disposable
  public var itemSelected: IMMap.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemDeselected: IMMap.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemAccessoryButtonTapped: IMMap.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemInserted: IMMap.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemDeleted: IMMap.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemMoved: IMMap.ControlEvent<IMMap.ItemMovedEvent> {
    get
  }
  public var willDisplayCell: IMMap.ControlEvent<IMMap.WillDisplayCellEvent> {
    get
  }
  public var didEndDisplayingCell: IMMap.ControlEvent<IMMap.DidEndDisplayingCellEvent> {
    get
  }
  public func modelSelected<T>(_ modelType: T.Type) -> IMMap.ControlEvent<T>
  public func modelDeselected<T>(_ modelType: T.Type) -> IMMap.ControlEvent<T>
  public func modelDeleted<T>(_ modelType: T.Type) -> IMMap.ControlEvent<T>
  public func model<T>(at indexPath: Foundation.IndexPath) throws -> T
}
@available(iOS 10.0, tvOS 10.0, *)
extension Reactive where Base : UIKit.UITableView {
  public var prefetchDataSource: IMMap.DelegateProxy<UIKit.UITableView, UIKit.UITableViewDataSourcePrefetching> {
    get
  }
  public func setPrefetchDataSource(_ prefetchDataSource: UIKit.UITableViewDataSourcePrefetching) -> IMMap.Disposable
  public var prefetchRows: IMMap.ControlEvent<[Foundation.IndexPath]> {
    get
  }
  public var cancelPrefetchingForRows: IMMap.ControlEvent<[Foundation.IndexPath]> {
    get
  }
}
public enum KingfisherError : Swift.Error {
  public enum RequestErrorReason {
    case emptyRequest
    case invalidURL(request: Foundation.URLRequest)
    case taskCancelled(task: IMMap.SessionDataTask, token: IMMap.SessionDataTask.CancelToken)
  }
  public enum ResponseErrorReason {
    case invalidURLResponse(response: Foundation.URLResponse)
    case invalidHTTPStatusCode(response: Foundation.HTTPURLResponse)
    case URLSessionError(error: Swift.Error)
    case dataModifyingFailed(task: IMMap.SessionDataTask)
    case noURLResponse(task: IMMap.SessionDataTask)
  }
  public enum CacheErrorReason {
    case fileEnumeratorCreationFailed(url: Foundation.URL)
    case invalidFileEnumeratorContent(url: Foundation.URL)
    case invalidURLResource(error: Swift.Error, key: Swift.String, url: Foundation.URL)
    case cannotLoadDataFromDisk(url: Foundation.URL, error: Swift.Error)
    case cannotCreateDirectory(path: Swift.String, error: Swift.Error)
    case imageNotExisting(key: Swift.String)
    case cannotConvertToData(object: Any, error: Swift.Error)
    case cannotSerializeImage(image: IMMap.KFCrossPlatformImage?, original: Foundation.Data?, serializer: IMMap.CacheSerializer)
    case cannotCreateCacheFile(fileURL: Foundation.URL, key: Swift.String, data: Foundation.Data, error: Swift.Error)
    case cannotSetCacheFileAttribute(filePath: Swift.String, attributes: [Foundation.FileAttributeKey : Any], error: Swift.Error)
  }
  public enum ProcessorErrorReason {
    case processingFailed(processor: IMMap.ImageProcessor, item: IMMap.ImageProcessItem)
  }
  public enum ImageSettingErrorReason {
    case emptySource
    case notCurrentSourceTask(result: IMMap.RetrieveImageResult?, error: Swift.Error?, source: IMMap.Source)
    case dataProviderError(provider: IMMap.ImageDataProvider, error: Swift.Error)
    case alternativeSourcesExhausted([IMMap.PropagationError])
  }
  case requestError(reason: IMMap.KingfisherError.RequestErrorReason)
  case responseError(reason: IMMap.KingfisherError.ResponseErrorReason)
  case cacheError(reason: IMMap.KingfisherError.CacheErrorReason)
  case processorError(reason: IMMap.KingfisherError.ProcessorErrorReason)
  case imageSettingError(reason: IMMap.KingfisherError.ImageSettingErrorReason)
  public var isTaskCancelled: Swift.Bool {
    get
  }
  public func isInvalidResponseStatusCode(_ code: Swift.Int) -> Swift.Bool
  public var isInvalidResponseStatusCode: Swift.Bool {
    get
  }
  public var isNotCurrentTask: Swift.Bool {
    get
  }
}
extension KingfisherError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension KingfisherError : Foundation.CustomNSError {
  public static let domain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
}
extension Request {
  public enum ValidationResult {
    case success
    case failure(Swift.Error)
  }
}
extension DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> IMMap.Request.ValidationResult
  @discardableResult
  public func validate(_ validation: @escaping IMMap.DataRequest.Validation) -> Self
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension DownloadRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, Foundation.URL?) -> IMMap.Request.ValidationResult
  @discardableResult
  public func validate(_ validation: @escaping IMMap.DownloadRequest.Validation) -> Self
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension Reactive where Base : UIKit.UIProgressView {
  public var progress: IMMap.Binder<Swift.Float> {
    get
  }
}
public enum Source {
  public enum Identifier {
    public typealias Value = Swift.UInt
  }
  case network(IMMap.Resource)
  case provider(IMMap.ImageDataProvider)
  public var cacheKey: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension Array where Element : IMMap.QLView {
  @discardableResult
  public func set(_ edge: IMMap.QLAttribute, of value: CoreGraphics.CGFloat, priority: IMMap.QLPriority = .required) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func set(_ edges: IMMap.QLAttribute..., of value: CoreGraphics.CGFloat, priority: IMMap.QLPriority = .required) -> [IMMap.QLMultipleConstraints]
  @discardableResult
  public func spread(_ axis: IMMap.QLAxis, stretchEdgesToSuperview: Swift.Bool = false, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func layoutToSuperview(axis: IMMap.QLAxis, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> [IMMap.QLAxisConstraints]
  @discardableResult
  public func layoutToSuperview(_ edge: IMMap.QLAttribute, ratio: CoreGraphics.CGFloat = 1, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func layout(_ firstEdge: IMMap.QLAttribute? = nil, to anchorEdge: IMMap.QLAttribute, of anchorView: IMMap.QLView, ratio: CoreGraphics.CGFloat = 1, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func layout(_ edges: IMMap.QLAttribute..., to anchorView: IMMap.QLView, ratio: CoreGraphics.CGFloat = 1, offset: CoreGraphics.CGFloat = 0, priority: IMMap.QLPriority = .required) -> [IMMap.QLMultipleConstraints]
  public var isValidForQuickLayout: Swift.Bool {
    get
  }
}
public struct Logging {
  public typealias LogURLRequest = (Foundation.URLRequest) -> Swift.Bool
  public static var URLRequests: IMMap.Logging.LogURLRequest
}
extension EKAttributes {
  public struct LifecycleEvents {
    public typealias Event = () -> Swift.Void
    public var willAppear: IMMap.EKAttributes.LifecycleEvents.Event?
    public var didAppear: IMMap.EKAttributes.LifecycleEvents.Event?
    public var willDisappear: IMMap.EKAttributes.LifecycleEvents.Event?
    public var didDisappear: IMMap.EKAttributes.LifecycleEvents.Event?
    public init(willAppear: IMMap.EKAttributes.LifecycleEvents.Event? = nil, didAppear: IMMap.EKAttributes.LifecycleEvents.Event? = nil, willDisappear: IMMap.EKAttributes.LifecycleEvents.Event? = nil, didDisappear: IMMap.EKAttributes.LifecycleEvents.Event? = nil)
  }
}
@objc final public class EKTextField : UIKit.UIView {
  final public var text: Swift.String {
    get
    set
  }
  public init(with content: IMMap.EKProperty.TextFieldContent)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  final public func makeFirstResponder()
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension ObservableType {
  public func timeout(_ dueTime: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
  public func timeout<Source>(_ dueTime: IMMap.RxTimeInterval, other: Source, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element> where Source : IMMap.ObservableConvertibleType, Self.Element == Source.Element
}
extension PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == IMMap.CompletableTrait {
  public func andThen<Element>(_ second: IMMap.Single<Element>) -> IMMap.Single<Element>
  public func andThen<Element>(_ second: IMMap.Maybe<Element>) -> IMMap.Maybe<Element>
  public func andThen(_ second: IMMap.Completable) -> IMMap.Completable
  public func andThen<Element>(_ second: IMMap.Observable<Element>) -> IMMap.Observable<Element>
}
extension ObservableType {
  public func skipWhile(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> IMMap.Observable<Self.Element>
}
extension UISearchController : IMMap.HasDelegate {
  public typealias Delegate = UIKit.UISearchControllerDelegate
}
@available(iOS 8.0, *)
open class RxSearchControllerDelegateProxy : IMMap.DelegateProxy<UIKit.UISearchController, UIKit.UISearchControllerDelegate>, IMMap.DelegateProxyType, UIKit.UISearchControllerDelegate {
  weak public var searchController: UIKit.UISearchController? {
    get
    }
  public init(searchController: UIKit.UISearchController)
  public static func registerKnownImplementations()
  override public init<Proxy>(parentObject: UIKit.UISearchController, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UISearchController, UIKit.UISearchControllerDelegate>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UISearchControllerDelegate, Proxy.ParentObject == UIKit.UISearchController
  @objc deinit
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == IMMap.SignalSharingStrategy {
  public func emit<Observer>(to observer: Observer) -> IMMap.Disposable where Observer : IMMap.ObserverType, Self.Element == Observer.Element
  public func emit<Observer>(to observer: Observer) -> IMMap.Disposable where Observer : IMMap.ObserverType, Observer.Element == Self.Element?
  public func emit(to relay: IMMap.BehaviorRelay<Self.Element>) -> IMMap.Disposable
  public func emit(to relay: IMMap.BehaviorRelay<Self.Element?>) -> IMMap.Disposable
  public func emit(to relay: IMMap.PublishRelay<Self.Element>) -> IMMap.Disposable
  public func emit(to relay: IMMap.PublishRelay<Self.Element?>) -> IMMap.Disposable
  public func emit(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> IMMap.Disposable
}
@objc final public class EKRatingMessageView : UIKit.UIView {
  public init(with message: IMMap.EKRatingMessage)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct EKRatingMessage {
  public typealias Selection = (Swift.Int) -> Swift.Void
  public var initialTitle: IMMap.EKProperty.LabelContent
  public var initialDescription: IMMap.EKProperty.LabelContent
  public var ratingItems: [IMMap.EKProperty.EKRatingItemContent]
  public var buttonBarContent: IMMap.EKProperty.ButtonBarContent
  public var selection: IMMap.EKRatingMessage.Selection!
  public var selectedIndex: Swift.Int? {
    get
    set
  }
  public init(initialTitle: IMMap.EKProperty.LabelContent, initialDescription: IMMap.EKProperty.LabelContent, ratingItems: [IMMap.EKProperty.EKRatingItemContent], buttonBarContent: IMMap.EKProperty.ButtonBarContent, selection: IMMap.EKRatingMessage.Selection? = nil)
}
public struct ImageLoadingResult {
  public let image: IMMap.KFCrossPlatformImage
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
}
public struct DownloadTask {
  public let sessionTask: IMMap.SessionDataTask
  public let cancelToken: IMMap.SessionDataTask.CancelToken
  public func cancel()
}
open class ImageDownloader {
  public static let `default`: IMMap.ImageDownloader
  open var downloadTimeout: Foundation.TimeInterval
  open var trustedHosts: Swift.Set<Swift.String>?
  open var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
    set
  }
  open var requestsUsePipelining: Swift.Bool
  weak open var delegate: IMMap.ImageDownloaderDelegate?
  weak open var authenticationChallengeResponder: IMMap.AuthenticationChallengeResponsable?
  public init(name: Swift.String)
  @objc deinit
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: IMMap.KingfisherParsedOptionsInfo, completionHandler: ((IMMap.KFResult<IMMap.ImageLoadingResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.ImageLoadingResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
}
extension ImageDownloader {
  public func cancelAll()
  public func cancel(url: Foundation.URL)
}
extension ImageDownloader : IMMap.AuthenticationChallengeResponsable {
}
extension ImageDownloader : IMMap.ImageDownloaderDelegate {
}
extension UIPickerView : IMMap.HasDataSource {
  public typealias DataSource = UIKit.UIPickerViewDataSource
}
public class RxPickerViewDataSourceProxy : IMMap.DelegateProxy<UIKit.UIPickerView, UIKit.UIPickerViewDataSource>, IMMap.DelegateProxyType, UIKit.UIPickerViewDataSource {
  weak public var pickerView: UIKit.UIPickerView? {
    get
    }
  public init(pickerView: IMMap.RxPickerViewDataSourceProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc public func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent component: Swift.Int) -> Swift.Int
  override public func setForwardToDelegate(_ forwardToDelegate: UIKit.UIPickerViewDataSource?, retainDelegate: Swift.Bool)
  override public init<Proxy>(parentObject: UIKit.UIPickerView, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UIPickerView, UIKit.UIPickerViewDataSource>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UIPickerViewDataSource, Proxy.ParentObject == UIKit.UIPickerView
  @objc deinit
}
extension Reactive where Base : UIKit.UIImageView {
  public var image: IMMap.Binder<UIKit.UIImage?> {
    get
  }
}
extension ObservableType {
  public func skipUntil<Source>(_ other: Source) -> IMMap.Observable<Self.Element> where Source : IMMap.ObservableType
}
extension Reactive where Base : UIKit.UIAlertAction {
  public var isEnabled: IMMap.Binder<Swift.Bool> {
    get
  }
}
public class SerialDispatchQueueScheduler : IMMap.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  convenience public init(internalSerialQueueName: Swift.String, serialQueueConfiguration: ((Dispatch.DispatchQueue) -> Swift.Void)? = nil, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  convenience public init(queue: Dispatch.DispatchQueue, internalSerialQueueName: Swift.String, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  @available(iOS 8, OSX 10.10, *)
  convenience public init(qos: Dispatch.DispatchQoS, internalSerialQueueName: Swift.String = "rx.global_dispatch_queue.serial", leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: IMMap.RxTimeInterval, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: IMMap.RxTimeInterval, period: IMMap.RxTimeInterval, action: @escaping (StateType) -> StateType) -> IMMap.Disposable
  @objc deinit
}
extension Reactive where Base : UIKit.UINavigationItem {
  public var title: IMMap.Binder<Swift.String?> {
    get
  }
}
final public class CompositeDisposable : IMMap.DisposeBase, IMMap.Cancelable {
  public struct DisposeKey {
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  override public init()
  public init(_ disposable1: IMMap.Disposable, _ disposable2: IMMap.Disposable)
  public init(_ disposable1: IMMap.Disposable, _ disposable2: IMMap.Disposable, _ disposable3: IMMap.Disposable)
  public init(_ disposable1: IMMap.Disposable, _ disposable2: IMMap.Disposable, _ disposable3: IMMap.Disposable, _ disposable4: IMMap.Disposable, _ disposables: IMMap.Disposable...)
  public init(disposables: [IMMap.Disposable])
  final public func insert(_ disposable: IMMap.Disposable) -> IMMap.CompositeDisposable.DisposeKey?
  final public var count: Swift.Int {
    get
  }
  final public func remove(for disposeKey: IMMap.CompositeDisposable.DisposeKey)
  final public func dispose()
  @objc deinit
}
extension Disposables {
  public static func create(_ disposable1: IMMap.Disposable, _ disposable2: IMMap.Disposable, _ disposable3: IMMap.Disposable) -> IMMap.Cancelable
  public static func create(_ disposable1: IMMap.Disposable, _ disposable2: IMMap.Disposable, _ disposable3: IMMap.Disposable, _ disposables: IMMap.Disposable...) -> IMMap.Cancelable
  public static func create(_ disposables: [IMMap.Disposable]) -> IMMap.Cancelable
}
public enum SubjectLifetimeScope {
  case whileConnected
  case forever
  public static func == (a: IMMap.SubjectLifetimeScope, b: IMMap.SubjectLifetimeScope) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension ObservableType {
  public func share(replay: Swift.Int = 0, scope: IMMap.SubjectLifetimeScope = .whileConnected) -> IMMap.Observable<Self.Element>
}
extension ObservableConvertibleType {
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorJustReturn: Self.Element) -> IMMap.SharedSequence<S, Self.Element> where S : IMMap.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorDriveWith: IMMap.SharedSequence<S, Self.Element>) -> IMMap.SharedSequence<S, Self.Element> where S : IMMap.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorRecover: @escaping (Swift.Error) -> IMMap.SharedSequence<S, Self.Element>) -> IMMap.SharedSequence<S, Self.Element> where S : IMMap.SharingStrategyProtocol
}
extension Reactive where Base : UIKit.NSLayoutConstraint {
  public var constant: IMMap.Binder<CoreGraphics.CGFloat> {
    get
  }
  @available(iOS 8, OSX 10.10, *)
  public var active: IMMap.Binder<Swift.Bool> {
    get
  }
}
extension ObservableType {
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (IMMap.Observable<Error>) -> TriggerObservable) -> IMMap.Observable<Self.Element> where TriggerObservable : IMMap.ObservableType, Error : Swift.Error
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (IMMap.Observable<Swift.Error>) -> TriggerObservable) -> IMMap.Observable<Self.Element> where TriggerObservable : IMMap.ObservableType
}
public protocol FontResourceType {
  var fontName: Swift.String { get }
}
public struct FontResource : IMMap.FontResourceType {
  public let fontName: Swift.String
  public init(fontName: Swift.String)
}
final public class BehaviorSubject<Element> : IMMap.Observable<Element>, IMMap.SubjectType, IMMap.ObserverType, IMMap.Cancelable {
  public typealias SubjectObserverType = IMMap.BehaviorSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(value: Element)
  final public func value() throws -> Element
  final public func on(_ event: IMMap.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where Element == Observer.Element, Observer : IMMap.ObserverType
  final public func asObserver() -> IMMap.BehaviorSubject<Element>
  final public func dispose()
  @objc deinit
  public typealias Observer = IMMap.BehaviorSubject<Element>
}
public protocol Resource {
  var cacheKey: Swift.String { get }
  var downloadURL: Foundation.URL { get }
}
extension Resource {
  public func convertToSource() -> IMMap.Source
}
public struct ImageResource : IMMap.Resource {
  public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil)
  public let cacheKey: Swift.String
  public let downloadURL: Foundation.URL
}
extension URL : IMMap.Resource {
  public var cacheKey: Swift.String {
    get
  }
  public var downloadURL: Foundation.URL {
    get
  }
}
open class SessionManager {
  public enum MultipartFormDataEncodingResult {
    case success(request: IMMap.UploadRequest, streamingFromDisk: Swift.Bool, streamFileURL: Foundation.URL?)
    case failure(Swift.Error)
  }
  public static let `default`: IMMap.SessionManager
  public static let defaultHTTPHeaders: IMMap.HTTPHeaders
  public static let multipartFormDataEncodingMemoryThreshold: Swift.UInt64
  final public let session: Foundation.URLSession
  final public let delegate: IMMap.AFSessionDelegate
  open var startRequestsImmediately: Swift.Bool
  open var adapter: IMMap.RequestAdapter?
  open var retrier: IMMap.RequestRetrier? {
    get
    set
  }
  open var backgroundCompletionHandler: (() -> Swift.Void)?
  public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.default, delegate: IMMap.AFSessionDelegate = AFSessionDelegate(), serverTrustPolicyManager: IMMap.ServerTrustPolicyManager? = nil)
  public init?(session: Foundation.URLSession, delegate: IMMap.AFSessionDelegate, serverTrustPolicyManager: IMMap.ServerTrustPolicyManager? = nil)
  @objc deinit
  @discardableResult
  open func request(_ url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .get, parameters: IMMap.Parameters? = nil, encoding: IMMap.ParameterEncoding = URLEncoding.default, headers: IMMap.HTTPHeaders? = nil) -> IMMap.DataRequest
  @discardableResult
  open func request(_ urlRequest: IMMap.URLRequestConvertible) -> IMMap.DataRequest
  @discardableResult
  open func download(_ url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .get, parameters: IMMap.Parameters? = nil, encoding: IMMap.ParameterEncoding = URLEncoding.default, headers: IMMap.HTTPHeaders? = nil, to destination: IMMap.DownloadRequest.DownloadFileDestination? = nil) -> IMMap.DownloadRequest
  @discardableResult
  open func download(_ urlRequest: IMMap.URLRequestConvertible, to destination: IMMap.DownloadRequest.DownloadFileDestination? = nil) -> IMMap.DownloadRequest
  @discardableResult
  open func download(resumingWith resumeData: Foundation.Data, to destination: IMMap.DownloadRequest.DownloadFileDestination? = nil) -> IMMap.DownloadRequest
  @discardableResult
  open func upload(_ fileURL: Foundation.URL, to url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .post, headers: IMMap.HTTPHeaders? = nil) -> IMMap.UploadRequest
  @discardableResult
  open func upload(_ fileURL: Foundation.URL, with urlRequest: IMMap.URLRequestConvertible) -> IMMap.UploadRequest
  @discardableResult
  open func upload(_ data: Foundation.Data, to url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .post, headers: IMMap.HTTPHeaders? = nil) -> IMMap.UploadRequest
  @discardableResult
  open func upload(_ data: Foundation.Data, with urlRequest: IMMap.URLRequestConvertible) -> IMMap.UploadRequest
  @discardableResult
  open func upload(_ stream: Foundation.InputStream, to url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .post, headers: IMMap.HTTPHeaders? = nil) -> IMMap.UploadRequest
  @discardableResult
  open func upload(_ stream: Foundation.InputStream, with urlRequest: IMMap.URLRequestConvertible) -> IMMap.UploadRequest
  open func upload(multipartFormData: @escaping (IMMap.MultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold, to url: IMMap.URLConvertible, method: IMMap.HTTPMethod = .post, headers: IMMap.HTTPHeaders? = nil, queue: Dispatch.DispatchQueue? = nil, encodingCompletion: ((IMMap.SessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
  open func upload(multipartFormData: @escaping (IMMap.MultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold, with urlRequest: IMMap.URLRequestConvertible, queue: Dispatch.DispatchQueue? = nil, encodingCompletion: ((IMMap.SessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  @discardableResult
  open func stream(withHostName hostName: Swift.String, port: Swift.Int) -> IMMap.StreamRequest
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  @discardableResult
  open func stream(with netService: Foundation.NetService) -> IMMap.StreamRequest
}
extension ObservableType {
  public static func amb<Sequence>(_ sequence: Sequence) -> IMMap.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func amb<O2>(_ right: O2) -> IMMap.Observable<Self.Element> where O2 : IMMap.ObservableType, Self.Element == O2.Element
}
extension Bundle {
  public func url(forResource resource: IMMap.FileResourceType) -> Foundation.URL?
  public func path(forResource resource: IMMap.FileResourceType) -> Swift.String?
}
public enum ImageTransition {
  case none
  case fade(Foundation.TimeInterval)
  case flipFromLeft(Foundation.TimeInterval)
  case flipFromRight(Foundation.TimeInterval)
  case flipFromTop(Foundation.TimeInterval)
  case flipFromBottom(Foundation.TimeInterval)
  case custom(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, animations: ((UIKit.UIImageView, UIKit.UIImage) -> Swift.Void)?, completion: ((Swift.Bool) -> Swift.Void)?)
}
extension NSNotification.Name {
  public static let KingfisherDidCleanDiskCache: Foundation.Notification.Name
}
public let KingfisherDiskCacheCleanedHashKey: Swift.String
public enum CacheType {
  case none
  case memory
  case disk
  public var cached: Swift.Bool {
    get
  }
  public static func == (a: IMMap.CacheType, b: IMMap.CacheType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct CacheStoreResult {
  public let memoryCacheResult: IMMap.KFResult<(), Swift.Never>
  public let diskCacheResult: IMMap.KFResult<(), IMMap.KingfisherError>
}
extension UIImage : IMMap.CacheCostCalculable {
  public var cacheCost: Swift.Int {
    get
  }
}
extension Data : IMMap.DataTransformable {
  public func toData() throws -> Foundation.Data
  public static func fromData(_ data: Foundation.Data) throws -> Foundation.Data
  public static let empty: Foundation.Data
}
public enum ImageCacheResult {
  case disk(IMMap.KFCrossPlatformImage)
  case memory(IMMap.KFCrossPlatformImage)
  case none
  public var image: IMMap.KFCrossPlatformImage? {
    get
  }
  public var cacheType: IMMap.CacheType {
    get
  }
}
open class ImageCache {
  public static let `default`: IMMap.ImageCache
  final public let memoryStorage: IMMap.MemoryStorage.Backend<IMMap.KFCrossPlatformImage>
  final public let diskStorage: IMMap.DiskStorage.Backend<Foundation.Data>
  public typealias DiskCachePathClosure = (Foundation.URL, Swift.String) -> Foundation.URL
  public init(memoryStorage: IMMap.MemoryStorage.Backend<IMMap.KFCrossPlatformImage>, diskStorage: IMMap.DiskStorage.Backend<Foundation.Data>)
  convenience public init(name: Swift.String)
  convenience public init(name: Swift.String, cacheDirectoryURL: Foundation.URL?, diskCachePathClosure: IMMap.ImageCache.DiskCachePathClosure? = nil) throws
  @objc deinit
  open func store(_ image: IMMap.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: IMMap.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true, completionHandler: ((IMMap.CacheStoreResult) -> Swift.Void)? = nil)
  open func store(_ image: IMMap.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", cacheSerializer serializer: IMMap.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true, callbackQueue: IMMap.CallbackQueue = .untouch, completionHandler: ((IMMap.CacheStoreResult) -> Swift.Void)? = nil)
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", expiration: IMMap.StorageExpiration? = nil, callbackQueue: IMMap.CallbackQueue = .untouch, completionHandler: ((IMMap.CacheStoreResult) -> Swift.Void)? = nil)
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true, callbackQueue: IMMap.CallbackQueue = .untouch, completionHandler: (() -> Swift.Void)? = nil)
  open func retrieveImage(forKey key: Swift.String, options: IMMap.KingfisherOptionsInfo? = nil, callbackQueue: IMMap.CallbackQueue = .mainCurrentOrAsync, completionHandler: ((IMMap.KFResult<IMMap.ImageCacheResult, IMMap.KingfisherError>) -> Swift.Void)?)
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: IMMap.KingfisherOptionsInfo? = nil) -> IMMap.KFCrossPlatformImage?
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: IMMap.KingfisherOptionsInfo? = nil, callbackQueue: IMMap.CallbackQueue = .untouch, completionHandler: @escaping (IMMap.KFResult<IMMap.KFCrossPlatformImage?, IMMap.KingfisherError>) -> Swift.Void)
  public func clearCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func clearMemoryCache()
  open func clearDiskCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredMemoryCache()
  open func cleanExpiredDiskCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func backgroundCleanExpiredDiskCache()
  open func imageCachedType(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> IMMap.CacheType
  public func isCached(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.Bool
  open func hash(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
  open func calculateDiskStorageSize(completion handler: @escaping ((IMMap.KFResult<Swift.UInt, IMMap.KingfisherError>) -> Swift.Void))
  open func cachePath(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
}
extension UIApplication : IMMap.KingfisherCompatible {
}
extension KingfisherWrapper where Base : UIKit.UIApplication {
  public static var shared: UIKit.UIApplication? {
    get
  }
}
extension ImageCache {
  @available(*, deprecated, renamed: "init(name:cacheDirectoryURL:diskCachePathClosure:)", message: "Use `init(name:cacheDirectoryURL:diskCachePathClosure:)` instead")
  convenience public init(name: Swift.String, path: Swift.String?, diskCachePathClosure: IMMap.ImageCache.DiskCachePathClosure? = nil) throws
}
extension ObservableType {
  public func materialize() -> IMMap.Observable<IMMap.Event<Self.Element>>
}
extension EKAttributes {
  public enum Shadow {
    case none
    case active(with: IMMap.EKAttributes.Shadow.Value)
    public struct Value {
      public let radius: CoreGraphics.CGFloat
      public let opacity: Swift.Float
      public let color: IMMap.EKColor
      public let offset: CoreGraphics.CGSize
      public init(color: IMMap.EKColor = .black, opacity: Swift.Float, radius: CoreGraphics.CGFloat, offset: CoreGraphics.CGSize = .zero)
    }
  }
}
public struct ValidationError : Swift.Error, Swift.CustomStringConvertible {
  public let description: Swift.String
  public init(description: Swift.String)
}
public protocol Validatable {
  static func validate() throws
}
extension ObservableType {
  public static func combineLatest<Collection>(_ collection: Collection, resultSelector: @escaping ([Collection.Element.Element]) throws -> Self.Element) -> IMMap.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element : IMMap.ObservableType
  public static func combineLatest<Collection>(_ collection: Collection) -> IMMap.Observable<[Self.Element]> where Collection : Swift.Collection, Self.Element == Collection.Element.Element, Collection.Element : IMMap.ObservableType
}
public enum RxCocoaInterceptionMechanism {
  case unknown
  case kvo
  public static func == (a: IMMap.RxCocoaInterceptionMechanism, b: IMMap.RxCocoaInterceptionMechanism) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum RxCocoaObjCRuntimeError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown(target: Swift.AnyObject)
  case objectMessagesAlreadyBeingIntercepted(target: Swift.AnyObject, interceptionMechanism: IMMap.RxCocoaInterceptionMechanism)
  case selectorNotImplemented(target: Swift.AnyObject)
  case cantInterceptCoreFoundationTollFreeBridgedObjects(target: Swift.AnyObject)
  case threadingCollisionWithOtherInterceptionMechanism(target: Swift.AnyObject)
  case savingOriginalForwardingMethodFailed(target: Swift.AnyObject)
  case replacingMethodWithForwardingImplementation(target: Swift.AnyObject)
  case observingPerformanceSensitiveMessages(target: Swift.AnyObject)
  case observingMessagesWithUnsupportedReturnType(target: Swift.AnyObject)
}
extension RxCocoaObjCRuntimeError {
  public var debugDescription: Swift.String {
    get
  }
}
public struct EKAlertMessage {
  public enum ImagePosition {
    case top
    case left
    public static func == (a: IMMap.EKAlertMessage.ImagePosition, b: IMMap.EKAlertMessage.ImagePosition) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let imagePosition: IMMap.EKAlertMessage.ImagePosition
  public let simpleMessage: IMMap.EKSimpleMessage
  public let buttonBarContent: IMMap.EKProperty.ButtonBarContent
  public init(simpleMessage: IMMap.EKSimpleMessage, imagePosition: IMMap.EKAlertMessage.ImagePosition = .top, buttonBarContent: IMMap.EKProperty.ButtonBarContent)
}
open class DelegateProxy<P, D> : IMMap._RXDelegateProxy where P : AnyObject {
  public typealias ParentObject = P
  public typealias Delegate = D
  public init<Proxy>(parentObject: IMMap.DelegateProxy<P, D>.ParentObject, delegateProxy: Proxy.Type) where P == Proxy.ParentObject, D == Proxy.Delegate, Proxy : IMMap.DelegateProxy<P, D>, Proxy : IMMap.DelegateProxyType
  open func sentMessage(_ selector: ObjectiveC.Selector) -> IMMap.Observable<[Any]>
  open func methodInvoked(_ selector: ObjectiveC.Selector) -> IMMap.Observable<[Any]>
  @objc override dynamic open func _sentMessage(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  @objc override dynamic open func _methodInvoked(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  open func forwardToDelegate() -> IMMap.DelegateProxy<P, D>.Delegate?
  open func setForwardToDelegate(_ delegate: IMMap.DelegateProxy<P, D>.Delegate?, retainDelegate: Swift.Bool)
  @objc override dynamic open func responds(to aSelector: ObjectiveC.Selector!) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
extension ObservableType {
  public func takeUntil<Source>(_ other: Source) -> IMMap.Observable<Self.Element> where Source : IMMap.ObservableType
  public func takeUntil(_ behavior: IMMap.TakeUntilBehavior, predicate: @escaping (Self.Element) throws -> Swift.Bool) -> IMMap.Observable<Self.Element>
}
public enum TakeUntilBehavior {
  case inclusive
  case exclusive
  public static func == (a: IMMap.TakeUntilBehavior, b: IMMap.TakeUntilBehavior) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol CacheSerializer {
  func data(with image: IMMap.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  func image(with data: Foundation.Data, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
  @available(*, deprecated, message: "Deprecated. Implement the method with same name but with `KingfisherParsedOptionsInfo` instead.")
  func image(with data: Foundation.Data, options: IMMap.KingfisherOptionsInfo?) -> IMMap.KFCrossPlatformImage?
}
extension CacheSerializer {
  public func image(with data: Foundation.Data, options: IMMap.KingfisherOptionsInfo?) -> IMMap.KFCrossPlatformImage?
}
public struct DefaultCacheSerializer : IMMap.CacheSerializer {
  public static let `default`: IMMap.DefaultCacheSerializer
  public var compressionQuality: CoreGraphics.CGFloat
  public var preferCacheOriginalData: Swift.Bool
  public init()
  public func data(with image: IMMap.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public enum CallbackQueue {
  case mainAsync
  case mainCurrentOrAsync
  case untouch
  case dispatch(Dispatch.DispatchQueue)
  public func execute(_ block: @escaping () -> Swift.Void)
}
extension ObservableType {
  public func asSingle() -> IMMap.Single<Self.Element>
  public func first() -> IMMap.Single<Self.Element?>
  public func asMaybe() -> IMMap.Maybe<Self.Element>
}
extension ObservableType where Self.Element == Swift.Never {
  public func asCompletable() -> IMMap.Completable
}
public protocol RxTableViewDataSourceType {
  associatedtype Element
  func tableView(_ tableView: UIKit.UITableView, observedEvent: IMMap.Event<Self.Element>)
}
public struct KeyValueObservingOptions : Swift.OptionSet {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let initial: IMMap.KeyValueObservingOptions
  public static let new: IMMap.KeyValueObservingOptions
  public typealias Element = IMMap.KeyValueObservingOptions
  public typealias ArrayLiteralElement = IMMap.KeyValueObservingOptions
  public typealias RawValue = Swift.UInt
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: IMMap.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> IMMap.Observable<Element?> where Element : IMMap.KVORepresentable
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: IMMap.KeyValueObservingOptions = [.new, .initial]) -> IMMap.Observable<Element?> where Element : IMMap.KVORepresentable
}
extension TypedStoryboardSegueInfo {
  public init?<SegueIdentifier>(segueIdentifier: SegueIdentifier, segue: UIKit.UIStoryboardSegue) where Segue == SegueIdentifier.SegueType, Source == SegueIdentifier.SourceType, Destination == SegueIdentifier.DestinationType, SegueIdentifier : IMMap.StoryboardSegueIdentifierType
}
public protocol AuthenticationChallengeResponsable : AnyObject {
  func downloader(_ downloader: IMMap.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  func downloader(_ downloader: IMMap.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension AuthenticationChallengeResponsable {
  public func downloader(_ downloader: IMMap.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  public func downloader(_ downloader: IMMap.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension ObservableType {
  public func sample<Source>(_ sampler: Source) -> IMMap.Observable<Self.Element> where Source : IMMap.ObservableType
}
extension Reactive where Base : AnyObject {
  public subscript<Value>(keyPath: Swift.ReferenceWritableKeyPath<Base, Value>) -> IMMap.Binder<Value> {
    get
  }
  public subscript<Value>(keyPath: Swift.ReferenceWritableKeyPath<Base, Value>, on scheduler: IMMap.ImmediateSchedulerType) -> IMMap.Binder<Value> {
    get
  }
}
extension Reactive where Base : UIKit.UIActivityIndicatorView {
  public var isAnimating: IMMap.Binder<Swift.Bool> {
    get
  }
}
public enum ImageProcessItem {
  case image(IMMap.KFCrossPlatformImage)
  case data(Foundation.Data)
}
public protocol ImageProcessor {
  var identifier: Swift.String { get }
  @available(*, deprecated, message: "Deprecated. Implement the method with same name but with `KingfisherParsedOptionsInfo` instead.")
  func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherOptionsInfo) -> IMMap.KFCrossPlatformImage?
  func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
extension ImageProcessor {
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
extension ImageProcessor {
  public func append(another: IMMap.ImageProcessor) -> IMMap.ImageProcessor
}
public struct DefaultImageProcessor : IMMap.ImageProcessor {
  public static let `default`: IMMap.DefaultImageProcessor
  public let identifier: Swift.String
  public init()
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct RectCorner : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let topLeft: IMMap.RectCorner
  public static let topRight: IMMap.RectCorner
  public static let bottomLeft: IMMap.RectCorner
  public static let bottomRight: IMMap.RectCorner
  public static let all: IMMap.RectCorner
  public init(rawValue: Swift.Int)
  public typealias Element = IMMap.RectCorner
  public typealias ArrayLiteralElement = IMMap.RectCorner
  public typealias RawValue = Swift.Int
}
public struct BlendImageProcessor : IMMap.ImageProcessor {
  public let identifier: Swift.String
  public let blendMode: CoreGraphics.CGBlendMode
  public let alpha: CoreGraphics.CGFloat
  public let backgroundColor: IMMap.KFCrossPlatformColor?
  public init(blendMode: CoreGraphics.CGBlendMode, alpha: CoreGraphics.CGFloat = 1.0, backgroundColor: IMMap.KFCrossPlatformColor? = nil)
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct RoundCornerImageProcessor : IMMap.ImageProcessor {
  public enum Radius {
    case widthFraction(CoreGraphics.CGFloat)
    case heightFraction(CoreGraphics.CGFloat)
    case point(CoreGraphics.CGFloat)
  }
  public let identifier: Swift.String
  @available(*, deprecated, message: "Use `radius` property instead.")
  public var cornerRadius: CoreGraphics.CGFloat {
    get
  }
  public let radius: IMMap.RoundCornerImageProcessor.Radius
  public let roundingCorners: IMMap.RectCorner
  public let targetSize: CoreGraphics.CGSize?
  public let backgroundColor: IMMap.KFCrossPlatformColor?
  public init(cornerRadius: CoreGraphics.CGFloat, targetSize: CoreGraphics.CGSize? = nil, roundingCorners corners: IMMap.RectCorner = .all, backgroundColor: IMMap.KFCrossPlatformColor? = nil)
  public init(radius: IMMap.RoundCornerImageProcessor.Radius, targetSize: CoreGraphics.CGSize? = nil, roundingCorners corners: IMMap.RectCorner = .all, backgroundColor: IMMap.KFCrossPlatformColor? = nil)
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public enum ContentMode {
  case none
  case aspectFit
  case aspectFill
  public static func == (a: IMMap.ContentMode, b: IMMap.ContentMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct ResizingImageProcessor : IMMap.ImageProcessor {
  public let identifier: Swift.String
  public let referenceSize: CoreGraphics.CGSize
  public let targetContentMode: IMMap.ContentMode
  public init(referenceSize: CoreGraphics.CGSize, mode: IMMap.ContentMode = .none)
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct BlurImageProcessor : IMMap.ImageProcessor {
  public let identifier: Swift.String
  public let blurRadius: CoreGraphics.CGFloat
  public init(blurRadius: CoreGraphics.CGFloat)
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct OverlayImageProcessor : IMMap.ImageProcessor {
  public let identifier: Swift.String
  public let overlay: IMMap.KFCrossPlatformColor
  public let fraction: CoreGraphics.CGFloat
  public init(overlay: IMMap.KFCrossPlatformColor, fraction: CoreGraphics.CGFloat = 0.5)
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct TintImageProcessor : IMMap.ImageProcessor {
  public let identifier: Swift.String
  public let tint: IMMap.KFCrossPlatformColor
  public init(tint: IMMap.KFCrossPlatformColor)
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct ColorControlsProcessor : IMMap.ImageProcessor {
  public let identifier: Swift.String
  public let brightness: CoreGraphics.CGFloat
  public let contrast: CoreGraphics.CGFloat
  public let saturation: CoreGraphics.CGFloat
  public let inputEV: CoreGraphics.CGFloat
  public init(brightness: CoreGraphics.CGFloat, contrast: CoreGraphics.CGFloat, saturation: CoreGraphics.CGFloat, inputEV: CoreGraphics.CGFloat)
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct BlackWhiteProcessor : IMMap.ImageProcessor {
  public let identifier: Swift.String
  public init()
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct CroppingImageProcessor : IMMap.ImageProcessor {
  public let identifier: Swift.String
  public let size: CoreGraphics.CGSize
  public let anchor: CoreGraphics.CGPoint
  public init(size: CoreGraphics.CGSize, anchor: CoreGraphics.CGPoint = CGPoint(x: 0.5, y: 0.5))
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct DownsamplingImageProcessor : IMMap.ImageProcessor {
  public let size: CoreGraphics.CGSize
  public let identifier: Swift.String
  public init(size: CoreGraphics.CGSize)
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
@available(*, deprecated, renamed: "|>", message: "Will be removed soon. Use `|>` instead.")
public func >> (left: IMMap.ImageProcessor, right: IMMap.ImageProcessor) -> IMMap.ImageProcessor
infix operator |> : AdditionPrecedence
public func |> (left: IMMap.ImageProcessor, right: IMMap.ImageProcessor) -> IMMap.ImageProcessor
final public class MainScheduler : IMMap.SerialDispatchQueueScheduler {
  public init()
  public static let instance: IMMap.MainScheduler
  public static let asyncInstance: IMMap.SerialDispatchQueueScheduler
  final public class func ensureExecutingOnScheduler(errorMessage: Swift.String? = nil)
  final public class func ensureRunningOnMainThread(errorMessage: Swift.String? = nil)
  @objc deinit
}
public class HistoricalScheduler : IMMap.VirtualTimeScheduler<IMMap.HistoricalSchedulerTimeConverter> {
  public init(initialClock: IMMap.RxTime = Date(timeIntervalSince1970: 0))
  override public init(initialClock: IMMap.HistoricalSchedulerTimeConverter.VirtualTimeUnit, converter: IMMap.HistoricalSchedulerTimeConverter)
  @objc deinit
}
public struct GroupedObservable<Key, Element> : IMMap.ObservableType {
  public let key: Key
  public init(key: Key, source: IMMap.Observable<Element>)
  public func subscribe<Observer>(_ observer: Observer) -> IMMap.Disposable where Element == Observer.Element, Observer : IMMap.ObserverType
  public func asObservable() -> IMMap.Observable<Element>
}
public protocol StoryboardViewControllerResourceType : IMMap.IdentifierType {
  associatedtype ViewControllerType
}
public struct StoryboardViewControllerResource<ViewController> : IMMap.StoryboardViewControllerResourceType {
  public typealias ViewControllerType = ViewController
  public let identifier: Swift.String
  public init(identifier: Swift.String)
}
public typealias QLMultipleConstraints = [IMMap.QLAttribute : UIKit.NSLayoutConstraint]
extension UILayoutPriority {
  public static let must: IMMap.QLPriority
  public static let zero: IMMap.QLPriority
}
public struct QLAttributePair {
  public let first: IMMap.QLAttribute
  public let second: IMMap.QLAttribute
}
public struct QLSizeConstraints {
  public let width: UIKit.NSLayoutConstraint
  public let height: UIKit.NSLayoutConstraint
}
public struct QLCenterConstraints {
  public let x: UIKit.NSLayoutConstraint
  public let y: UIKit.NSLayoutConstraint
}
public struct QLAxisConstraints {
  public let first: UIKit.NSLayoutConstraint
  public let second: UIKit.NSLayoutConstraint
}
public struct QLFillConstraints {
  public let center: IMMap.QLCenterConstraints
  public let size: IMMap.QLSizeConstraints
}
public struct QLPriorityPair {
  public let horizontal: IMMap.QLPriority
  public let vertical: IMMap.QLPriority
  public static var required: IMMap.QLPriorityPair {
    get
  }
  public static var must: IMMap.QLPriorityPair {
    get
  }
  public init(_ horizontal: IMMap.QLPriority, _ vertical: IMMap.QLPriority)
}
public enum QLAxis {
  case horizontally
  case vertically
  public var attributes: IMMap.QLAttributePair {
    get
  }
  public static func == (a: IMMap.QLAxis, b: IMMap.QLAxis) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension Observable {
  @available(*, deprecated, renamed: "from(optional:)", message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.")
  public static func from(_ optional: Element?) -> IMMap.Observable<Element>
  @available(*, deprecated, renamed: "from(optional:scheduler:)", message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.")
  public static func from(_ optional: Element?, scheduler: IMMap.ImmediateSchedulerType) -> IMMap.Observable<Element>
}
extension ObservableType {
  @available(*, deprecated, message: "Please use enumerated().map()")
  public func mapWithIndex<Result>(_ selector: @escaping (Self.Element, Swift.Int) throws -> Result) -> IMMap.Observable<Result>
  @available(*, deprecated, message: "Please use enumerated().flatMap()")
  public func flatMapWithIndex<Source>(_ selector: @escaping (Self.Element, Swift.Int) throws -> Source) -> IMMap.Observable<Source.Element> where Source : IMMap.ObservableConvertibleType
  @available(*, deprecated, message: "Please use enumerated().skipWhile().map()")
  public func skipWhileWithIndex(_ predicate: @escaping (Self.Element, Swift.Int) throws -> Swift.Bool) -> IMMap.Observable<Self.Element>
  @available(*, deprecated, message: "Please use enumerated().takeWhile().map()")
  public func takeWhileWithIndex(_ predicate: @escaping (Self.Element, Swift.Int) throws -> Swift.Bool) -> IMMap.Observable<Self.Element>
}
extension Disposable {
  @available(*, deprecated, renamed: "disposed(by:)", message: "use disposed(by:) instead")
  public func addDisposableTo(_ bag: IMMap.DisposeBag)
}
extension ObservableType {
  @available(*, deprecated, renamed: "share(replay:)", message: "use share(replay: 1) instead")
  public func shareReplayLatestWhileConnected() -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  @available(*, deprecated, renamed: "share(replay:)", message: "Suggested replacement is `share(replay: 1)`. In case old 3.x behavior of `shareReplay` is required please use `share(replay: 1, scope: .forever)` instead.")
  public func shareReplay(_ bufferSize: Swift.Int) -> IMMap.Observable<Self.Element>
}
@available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
final public class Variable<Element> {
  final public var value: Element {
    get
    set(newValue)
  }
  public init(_ value: Element)
  final public func asObservable() -> IMMap.Observable<Element>
  @objc deinit
}
extension ObservableType {
  @available(*, deprecated, renamed: "delay(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func delay(_ dueTime: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  @available(*, deprecated, renamed: "timeout(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func timeout(_ dueTime: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
  @available(*, deprecated, renamed: "timeout(_:other:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func timeout<OtherSource>(_ dueTime: Foundation.TimeInterval, other: OtherSource, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element> where OtherSource : IMMap.ObservableConvertibleType, Self.Element == OtherSource.Element
}
extension ObservableType {
  @available(*, deprecated, renamed: "skip(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func skip(_ duration: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType where Self.Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "interval(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public static func interval(_ period: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType where Self.Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "timer(_:period:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public static func timer(_ dueTime: Foundation.TimeInterval, period: Foundation.TimeInterval? = nil, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  @available(*, deprecated, renamed: "throttle(_:latest:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func throttle(_ dueTime: Foundation.TimeInterval, latest: Swift.Bool = true, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  @available(*, deprecated, renamed: "take(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func take(_ duration: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  @available(*, deprecated, renamed: "delaySubscription(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func delaySubscription(_ dueTime: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  @available(*, deprecated, renamed: "window(_:)", message: "Use DispatchTimeInterval overload instead.")
  public func window(timeSpan: Foundation.TimeInterval, count: Swift.Int, scheduler: IMMap.SchedulerType) -> IMMap.Observable<IMMap.Observable<Self.Element>>
}
extension PrimitiveSequence {
  @available(*, deprecated, renamed: "delay(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func delay(_ dueTime: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "delaySubscription(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func delaySubscription(_ dueTime: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "timeout(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func timeout(_ dueTime: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "timeout(_:other:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func timeout(_ dueTime: Foundation.TimeInterval, other: IMMap.PrimitiveSequence<Trait, Element>, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  @available(*, deprecated, renamed: "do(onSuccess:onError:onSubscribe:onSubscribed:onDispose:)")
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)?, onError: ((Swift.Error) throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> IMMap.Single<Self.Element>
}
extension ObservableType {
  @available(*, deprecated, renamed: "buffer(timeSpan:count:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func buffer(timeSpan: Foundation.TimeInterval, count: Swift.Int, scheduler: IMMap.SchedulerType) -> IMMap.Observable<[Self.Element]>
}
extension PrimitiveSequenceType where Self.Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "timer(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public static func timer(_ dueTime: Foundation.TimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension PrimitiveSequence where Trait == IMMap.CompletableTrait, Element == Swift.Never {
  @available(*, deprecated, renamed: "zip", message: "Use Completable.zip instead.")
  public static func merge<Collection>(_ sources: Collection) -> IMMap.Completable where Collection : Swift.Collection, Collection.Element == IMMap.Completable
  @available(*, deprecated, renamed: "zip", message: "Use Completable.zip instead.")
  public static func merge(_ sources: [IMMap.Completable]) -> IMMap.Completable
  @available(*, deprecated, renamed: "zip", message: "Use Completable.zip instead.")
  public static func merge(_ sources: IMMap.Completable...) -> IMMap.Completable
}
public struct PrimitiveSequence<Trait, Element> {
}
public protocol PrimitiveSequenceType {
  associatedtype Trait
  associatedtype Element
  @available(*, deprecated, renamed: "Trait")
  typealias TraitType = Self.Trait
  @available(*, deprecated, renamed: "Element")
  typealias ElementType = Self.Element
  var primitiveSequence: IMMap.PrimitiveSequence<Self.Trait, Self.Element> { get }
}
extension PrimitiveSequence : IMMap.PrimitiveSequenceType {
  public var primitiveSequence: IMMap.PrimitiveSequence<Trait, Element> {
    get
  }
}
extension PrimitiveSequence : IMMap.ObservableConvertibleType {
  public func asObservable() -> IMMap.Observable<Element>
}
extension PrimitiveSequence {
  public static func deferred(_ observableFactory: @escaping () throws -> IMMap.PrimitiveSequence<Trait, Element>) -> IMMap.PrimitiveSequence<Trait, Element>
  public func delay(_ dueTime: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
  public func delaySubscription(_ dueTime: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
  public func observeOn(_ scheduler: IMMap.ImmediateSchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
  public func subscribeOn(_ scheduler: IMMap.ImmediateSchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
  public func catchError(_ handler: @escaping (Swift.Error) throws -> IMMap.PrimitiveSequence<Trait, Element>) -> IMMap.PrimitiveSequence<Trait, Element>
  public func retry(_ maxAttemptCount: Swift.Int) -> IMMap.PrimitiveSequence<Trait, Element>
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (IMMap.Observable<Error>) -> TriggerObservable) -> IMMap.PrimitiveSequence<Trait, Element> where TriggerObservable : IMMap.ObservableType, Error : Swift.Error
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (IMMap.Observable<Swift.Error>) -> TriggerObservable) -> IMMap.PrimitiveSequence<Trait, Element> where TriggerObservable : IMMap.ObservableType
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> IMMap.PrimitiveSequence<Trait, Element>
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, primitiveSequenceFactory: @escaping (Resource) throws -> IMMap.PrimitiveSequence<Trait, Element>) -> IMMap.PrimitiveSequence<Trait, Element> where Resource : IMMap.Disposable
  public func timeout(_ dueTime: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
  public func timeout(_ dueTime: IMMap.RxTimeInterval, other: IMMap.PrimitiveSequence<Trait, Element>, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Trait, Element>
}
extension PrimitiveSequenceType where Self.Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: IMMap.RxTimeInterval, scheduler: IMMap.SchedulerType) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
}
extension Reactive where Base : UIKit.UIPageControl {
  public var currentPage: IMMap.Binder<Swift.Int> {
    get
  }
  public var numberOfPages: IMMap.Binder<Swift.Int> {
    get
  }
}
extension Disposables {
  public static func create(with dispose: @escaping () -> Swift.Void) -> IMMap.Cancelable
}
open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(IMMap.NetworkReachabilityManager.ConnectionType)
  }
  public enum ConnectionType {
    case ethernetOrWiFi
    case wwan
    public static func == (a: IMMap.NetworkReachabilityManager.ConnectionType, b: IMMap.NetworkReachabilityManager.ConnectionType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public typealias Listener = (IMMap.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnWWAN: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  open var networkReachabilityStatus: IMMap.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  open var listenerQueue: Dispatch.DispatchQueue
  open var listener: IMMap.NetworkReachabilityManager.Listener?
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var previousFlags: SystemConfiguration.SCNetworkReachabilityFlags
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening() -> Swift.Bool
  open func stopListening()
}
extension NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
}
public func == (lhs: IMMap.NetworkReachabilityManager.NetworkReachabilityStatus, rhs: IMMap.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
@available(iOS 8.0, OSX 10.10, OSXApplicationExtension 10.10, *)
extension Reactive where Base : WebKit.WKWebView {
  public var navigationDelegate: IMMap.DelegateProxy<WebKit.WKWebView, WebKit.WKNavigationDelegate> {
    get
  }
  public var didCommit: IMMap.Observable<WebKit.WKNavigation> {
    get
  }
  public var didStartLoad: IMMap.Observable<WebKit.WKNavigation> {
    get
  }
  public var didFinishLoad: IMMap.Observable<WebKit.WKNavigation> {
    get
  }
  public var didFailLoad: IMMap.Observable<(WebKit.WKNavigation, Swift.Error)> {
    get
  }
}
extension ObservableType {
  public static func generate(initialState: Self.Element, condition: @escaping (Self.Element) throws -> Swift.Bool, scheduler: IMMap.ImmediateSchedulerType = CurrentThreadScheduler.instance, iterate: @escaping (Self.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func concat<Source>(_ second: Source) -> IMMap.Observable<Self.Element> where Source : IMMap.ObservableConvertibleType, Self.Element == Source.Element
}
extension ObservableType {
  public static func concat<Sequence>(_ sequence: Sequence) -> IMMap.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == IMMap.Observable<Self.Element>
  public static func concat<Collection>(_ collection: Collection) -> IMMap.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element == IMMap.Observable<Self.Element>
  public static func concat(_ sources: IMMap.Observable<Self.Element>...) -> IMMap.Observable<Self.Element>
}
extension Reactive where Base : UIKit.UIPickerView {
  public var delegate: IMMap.DelegateProxy<UIKit.UIPickerView, UIKit.UIPickerViewDelegate> {
    get
  }
  public func setDelegate(_ delegate: UIKit.UIPickerViewDelegate) -> IMMap.Disposable
  public var dataSource: IMMap.DelegateProxy<UIKit.UIPickerView, UIKit.UIPickerViewDataSource> {
    get
  }
  public var itemSelected: IMMap.ControlEvent<(row: Swift.Int, component: Swift.Int)> {
    get
  }
  public func modelSelected<T>(_ modelType: T.Type) -> IMMap.ControlEvent<[T]>
  public func itemTitles<Sequence, Source>(_ source: Source) -> (@escaping (Swift.Int, Sequence.Element) -> Swift.String?) -> IMMap.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : IMMap.ObservableType
  public func itemAttributedTitles<Sequence, Source>(_ source: Source) -> (@escaping (Swift.Int, Sequence.Element) -> Foundation.NSAttributedString?) -> IMMap.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : IMMap.ObservableType
  public func items<Sequence, Source>(_ source: Source) -> (@escaping (Swift.Int, Sequence.Element, UIKit.UIView?) -> UIKit.UIView) -> IMMap.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : IMMap.ObservableType
  public func items<Source, Adapter>(adapter: Adapter) -> (Source) -> IMMap.Disposable where Source : IMMap.ObservableType, Adapter : IMMap.RxPickerViewDataSourceType, Adapter : UIKit.UIPickerViewDataSource, Adapter : UIKit.UIPickerViewDelegate, Source.Element == Adapter.Element
  public func model<T>(at indexPath: Foundation.IndexPath) throws -> T
}
extension EKAttributes {
  public enum WindowLevel {
    case alerts
    case statusBar
    case normal
    case custom(level: UIKit.UIWindow.Level)
    public var value: UIKit.UIWindow.Level {
      get
    }
  }
}
public enum SingleTrait {
}
public typealias Single<Element> = IMMap.PrimitiveSequence<IMMap.SingleTrait, Element>
public enum SingleEvent<Element> {
  case success(Element)
  case error(Swift.Error)
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public typealias SingleObserver = (IMMap.SingleEvent<Self.Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.SingleObserver) -> IMMap.Disposable) -> IMMap.Single<Self.Element>
  public func subscribe(_ observer: @escaping (IMMap.SingleEvent<Self.Element>) -> Swift.Void) -> IMMap.Disposable
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onError: ((Swift.Error) -> Swift.Void)? = nil) -> IMMap.Disposable
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public static func just(_ element: Self.Element) -> IMMap.Single<Self.Element>
  public static func just(_ element: Self.Element, scheduler: IMMap.ImmediateSchedulerType) -> IMMap.Single<Self.Element>
  public static func error(_ error: Swift.Error) -> IMMap.Single<Self.Element>
  public static func never() -> IMMap.Single<Self.Element>
}
extension PrimitiveSequenceType where Self.Trait == IMMap.SingleTrait {
  public func `do`(onSuccess: ((Self.Element) throws -> Swift.Void)? = nil, afterSuccess: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((Swift.Error) throws -> Swift.Void)? = nil, afterError: ((Swift.Error) throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> IMMap.Single<Self.Element>
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> IMMap.Maybe<Self.Element>
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> IMMap.Single<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> IMMap.Maybe<Result>
  public func flatMap<Result>(_ selector: @escaping (Self.Element) throws -> IMMap.Single<Result>) -> IMMap.Single<Result>
  public func flatMapMaybe<Result>(_ selector: @escaping (Self.Element) throws -> IMMap.Maybe<Result>) -> IMMap.Maybe<Result>
  public func flatMapCompletable(_ selector: @escaping (Self.Element) throws -> IMMap.Completable) -> IMMap.Completable
  public static func zip<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Self.Element]) throws -> Result) -> IMMap.PrimitiveSequence<Self.Trait, Result> where Collection : Swift.Collection, Collection.Element == IMMap.PrimitiveSequence<IMMap.SingleTrait, Self.Element>
  public static func zip<Collection>(_ collection: Collection) -> IMMap.PrimitiveSequence<Self.Trait, [Self.Element]> where Collection : Swift.Collection, Collection.Element == IMMap.PrimitiveSequence<IMMap.SingleTrait, Self.Element>
  public func catchErrorJustReturn(_ element: Self.Element) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
  public func asMaybe() -> IMMap.Maybe<Self.Element>
  public func asCompletable() -> IMMap.Completable
}
extension UISearchBar : IMMap.HasDelegate {
  public typealias Delegate = UIKit.UISearchBarDelegate
}
open class RxSearchBarDelegateProxy : IMMap.DelegateProxy<UIKit.UISearchBar, UIKit.UISearchBarDelegate>, IMMap.DelegateProxyType, UIKit.UISearchBarDelegate {
  weak public var searchBar: UIKit.UISearchBar? {
    get
    }
  public init(searchBar: IMMap.RxSearchBarDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  override public init<Proxy>(parentObject: UIKit.UISearchBar, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UISearchBar, UIKit.UISearchBarDelegate>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UISearchBarDelegate, Proxy.ParentObject == UIKit.UISearchBar
  @objc deinit
}
@available(iOS 8.0, *)
extension Reactive where Base : UIKit.UISearchController {
  public var delegate: IMMap.DelegateProxy<UIKit.UISearchController, UIKit.UISearchControllerDelegate> {
    get
  }
  public var didDismiss: IMMap.Observable<Swift.Void> {
    get
  }
  public var didPresent: IMMap.Observable<Swift.Void> {
    get
  }
  public var present: IMMap.Observable<Swift.Void> {
    get
  }
  public var willDismiss: IMMap.Observable<Swift.Void> {
    get
  }
  public var willPresent: IMMap.Observable<Swift.Void> {
    get
  }
}
public struct AnyObserver<Element> : IMMap.ObserverType {
  public typealias EventHandler = (IMMap.Event<Element>) -> Swift.Void
  public init(eventHandler: @escaping IMMap.AnyObserver<Element>.EventHandler)
  public init<Observer>(_ observer: Observer) where Element == Observer.Element, Observer : IMMap.ObserverType
  public func on(_ event: IMMap.Event<Element>)
  public func asObserver() -> IMMap.AnyObserver<Element>
}
extension ObserverType {
  public func asObserver() -> IMMap.AnyObserver<Self.Element>
  public func mapObserver<Result>(_ transform: @escaping (Result) throws -> Self.Element) -> IMMap.AnyObserver<Result>
}
public protocol ImageDownloaderDelegate : AnyObject {
  func imageDownloader(_ downloader: IMMap.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  func imageDownloader(_ downloader: IMMap.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: Swift.Error?)
  func imageDownloader(_ downloader: IMMap.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  func imageDownloader(_ downloader: IMMap.ImageDownloader, didDownload image: IMMap.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  func isValidStatusCode(_ code: Swift.Int, for downloader: IMMap.ImageDownloader) -> Swift.Bool
}
extension ImageDownloaderDelegate {
  public func imageDownloader(_ downloader: IMMap.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  public func imageDownloader(_ downloader: IMMap.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: Swift.Error?)
  public func imageDownloader(_ downloader: IMMap.ImageDownloader, didDownload image: IMMap.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  public func isValidStatusCode(_ code: Swift.Int, for downloader: IMMap.ImageDownloader) -> Swift.Bool
  public func imageDownloader(_ downloader: IMMap.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
}
extension Reactive where Base : UIKit.UITabBarController {
  public var willBeginCustomizing: IMMap.ControlEvent<[UIKit.UIViewController]> {
    get
  }
  public var willEndCustomizing: IMMap.ControlEvent<(viewControllers: [UIKit.UIViewController], changed: Swift.Bool)> {
    get
  }
  public var didEndCustomizing: IMMap.ControlEvent<(viewControllers: [UIKit.UIViewController], changed: Swift.Bool)> {
    get
  }
}
extension Reactive where Base : UIKit.UITabBarController {
  public var delegate: IMMap.DelegateProxy<UIKit.UITabBarController, UIKit.UITabBarControllerDelegate> {
    get
  }
  public var didSelect: IMMap.ControlEvent<UIKit.UIViewController> {
    get
  }
}
extension UIPickerView : IMMap.HasDelegate {
  public typealias Delegate = UIKit.UIPickerViewDelegate
}
open class RxPickerViewDelegateProxy : IMMap.DelegateProxy<UIKit.UIPickerView, UIKit.UIPickerViewDelegate>, IMMap.DelegateProxyType, UIKit.UIPickerViewDelegate {
  weak public var pickerView: UIKit.UIPickerView? {
    get
    }
  public init(pickerView: IMMap.RxPickerViewDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  override public init<Proxy>(parentObject: UIKit.UIPickerView, delegateProxy: Ï„_0_0.Type) where Proxy : IMMap.DelegateProxy<UIKit.UIPickerView, UIKit.UIPickerViewDelegate>, Proxy : IMMap.DelegateProxyType, Proxy.Delegate == UIKit.UIPickerViewDelegate, Proxy.ParentObject == UIKit.UIPickerView
  @objc deinit
}
extension Reactive where Base : UIKit.UISearchBar {
  public var delegate: IMMap.DelegateProxy<UIKit.UISearchBar, UIKit.UISearchBarDelegate> {
    get
  }
  public var text: IMMap.ControlProperty<Swift.String?> {
    get
  }
  public var value: IMMap.ControlProperty<Swift.String?> {
    get
  }
  public var selectedScopeButtonIndex: IMMap.ControlProperty<Swift.Int> {
    get
  }
  public var cancelButtonClicked: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var bookmarkButtonClicked: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var resultsListButtonClicked: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var searchButtonClicked: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var textDidBeginEditing: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public var textDidEndEditing: IMMap.ControlEvent<Swift.Void> {
    get
  }
  public func setDelegate(_ delegate: UIKit.UISearchBarDelegate) -> IMMap.Disposable
}
public class CurrentThreadScheduler : IMMap.ImmediateSchedulerType {
  public static let instance: IMMap.CurrentThreadScheduler
  public static var isScheduleRequired: Swift.Bool {
    get
  }
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> IMMap.Disposable) -> IMMap.Disposable
  @objc deinit
}
public typealias QLAttribute = UIKit.NSLayoutConstraint.Attribute
public typealias QLRelation = UIKit.NSLayoutConstraint.Relation
public typealias QLView = UIKit.UIView
public typealias QLPriority = UIKit.UILayoutPriority
extension Reactive where Base : UIKit.UIRefreshControl {
  public var isRefreshing: IMMap.Binder<Swift.Bool> {
    get
  }
}
extension Reactive where Base : UIKit.UICollectionView {
  public func items<Sequence, Source>(_ source: Source) -> (@escaping (UIKit.UICollectionView, Swift.Int, Sequence.Element) -> UIKit.UICollectionViewCell) -> IMMap.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : IMMap.ObservableType
  public func items<Sequence, Cell, Source>(cellIdentifier: Swift.String, cellType: Cell.Type = Cell.self) -> (Source) -> (@escaping (Swift.Int, Sequence.Element, Cell) -> Swift.Void) -> IMMap.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Cell : UIKit.UICollectionViewCell, Source : IMMap.ObservableType
  public func items<DataSource, Source>(dataSource: DataSource) -> (Source) -> IMMap.Disposable where DataSource : IMMap.RxCollectionViewDataSourceType, DataSource : UIKit.UICollectionViewDataSource, Source : IMMap.ObservableType, DataSource.Element == Source.Element
}
extension Reactive where Base : UIKit.UICollectionView {
  public typealias DisplayCollectionViewCellEvent = (cell: UIKit.UICollectionViewCell, at: Foundation.IndexPath)
  public typealias DisplayCollectionViewSupplementaryViewEvent = (supplementaryView: UIKit.UICollectionReusableView, elementKind: Swift.String, at: Foundation.IndexPath)
  public var dataSource: IMMap.DelegateProxy<UIKit.UICollectionView, UIKit.UICollectionViewDataSource> {
    get
  }
  public func setDataSource(_ dataSource: UIKit.UICollectionViewDataSource) -> IMMap.Disposable
  public var itemSelected: IMMap.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemDeselected: IMMap.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemHighlighted: IMMap.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemUnhighlighted: IMMap.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var willDisplayCell: IMMap.ControlEvent<IMMap.Reactive<Base>.DisplayCollectionViewCellEvent> {
    get
  }
  public var willDisplaySupplementaryView: IMMap.ControlEvent<IMMap.Reactive<Base>.DisplayCollectionViewSupplementaryViewEvent> {
    get
  }
  public var didEndDisplayingCell: IMMap.ControlEvent<IMMap.Reactive<Base>.DisplayCollectionViewCellEvent> {
    get
  }
  public var didEndDisplayingSupplementaryView: IMMap.ControlEvent<IMMap.Reactive<Base>.DisplayCollectionViewSupplementaryViewEvent> {
    get
  }
  public func modelSelected<T>(_ modelType: T.Type) -> IMMap.ControlEvent<T>
  public func modelDeselected<T>(_ modelType: T.Type) -> IMMap.ControlEvent<T>
  public func model<T>(at indexPath: Foundation.IndexPath) throws -> T
}
@available(iOS 10.0, tvOS 10.0, *)
extension Reactive where Base : UIKit.UICollectionView {
  public var prefetchDataSource: IMMap.DelegateProxy<UIKit.UICollectionView, UIKit.UICollectionViewDataSourcePrefetching> {
    get
  }
  public func setPrefetchDataSource(_ prefetchDataSource: UIKit.UICollectionViewDataSourcePrefetching) -> IMMap.Disposable
  public var prefetchItems: IMMap.ControlEvent<[Foundation.IndexPath]> {
    get
  }
  public var cancelPrefetchingForItems: IMMap.ControlEvent<[Foundation.IndexPath]> {
    get
  }
}
extension ObservableType {
  public func bind<Observer>(to observers: Observer...) -> IMMap.Disposable where Observer : IMMap.ObserverType, Self.Element == Observer.Element
  public func bind<Observer>(to observers: Observer...) -> IMMap.Disposable where Observer : IMMap.ObserverType, Observer.Element == Self.Element?
  public func bind<Result>(to binder: (Self) -> Result) -> Result
  public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func bind(onNext: @escaping (Self.Element) -> Swift.Void) -> IMMap.Disposable
}
public struct EKSimpleMessage {
  public let image: IMMap.EKProperty.ImageContent?
  public let title: IMMap.EKProperty.LabelContent
  public let description: IMMap.EKProperty.LabelContent
  public init(image: IMMap.EKProperty.ImageContent? = nil, title: IMMap.EKProperty.LabelContent, description: IMMap.EKProperty.LabelContent)
}
extension Reactive where Base : UIKit.UIControl {
  public var isEnabled: IMMap.Binder<Swift.Bool> {
    get
  }
  public var isSelected: IMMap.Binder<Swift.Bool> {
    get
  }
  public func controlEvent(_ controlEvents: UIKit.UIControl.Event) -> IMMap.ControlEvent<()>
  public func controlProperty<T>(editingEvents: UIKit.UIControl.Event, getter: @escaping (Base) -> T, setter: @escaping (Base, T) -> Swift.Void) -> IMMap.ControlProperty<T>
}
public protocol Cancelable : IMMap.Disposable {
  var isDisposed: Swift.Bool { get }
}
extension ObservableType {
  public func takeLast(_ count: Swift.Int) -> IMMap.Observable<Self.Element>
}
extension StringResource {
  public func localized() -> Swift.String
}
public enum RxError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case disposed(object: Swift.AnyObject)
  case overflow
  case argumentOutOfRange
  case noElements
  case moreThanOneElement
  case timeout
}
extension RxError {
  public var debugDescription: Swift.String {
    get
  }
}
extension ObservableType {
  public static func from(optional: Self.Element?) -> IMMap.Observable<Self.Element>
  public static func from(optional: Self.Element?, scheduler: IMMap.ImmediateSchedulerType) -> IMMap.Observable<Self.Element>
}
public enum CompletableTrait {
}
public typealias Completable = IMMap.PrimitiveSequence<IMMap.CompletableTrait, Swift.Never>
public enum CompletableEvent {
  case error(Swift.Error)
  case completed
}
extension PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == IMMap.CompletableTrait {
  public typealias CompletableObserver = (IMMap.CompletableEvent) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.CompletableObserver) -> IMMap.Disposable) -> IMMap.PrimitiveSequence<Self.Trait, Self.Element>
  public func subscribe(_ observer: @escaping (IMMap.CompletableEvent) -> Swift.Void) -> IMMap.Disposable
  public func subscribe(onCompleted: (() -> Swift.Void)? = nil, onError: ((Swift.Error) -> Swift.Void)? = nil) -> IMMap.Disposable
}
extension PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == IMMap.CompletableTrait {
  public static func error(_ error: Swift.Error) -> IMMap.Completable
  public static func never() -> IMMap.Completable
  public static func empty() -> IMMap.Completable
}
extension PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == IMMap.CompletableTrait {
  public func `do`(onError: ((Swift.Error) throws -> Swift.Void)? = nil, afterError: ((Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> IMMap.Completable
  public func concat(_ second: IMMap.Completable) -> IMMap.Completable
  public static func concat<Sequence>(_ sequence: Sequence) -> IMMap.Completable where Sequence : Swift.Sequence, Sequence.Element == IMMap.Completable
  public static func concat<Collection>(_ collection: Collection) -> IMMap.Completable where Collection : Swift.Collection, Collection.Element == IMMap.Completable
  public static func concat(_ sources: IMMap.Completable...) -> IMMap.Completable
  public static func zip<Collection>(_ sources: Collection) -> IMMap.Completable where Collection : Swift.Collection, Collection.Element == IMMap.Completable
  public static func zip(_ sources: [IMMap.Completable]) -> IMMap.Completable
  public static func zip(_ sources: IMMap.Completable...) -> IMMap.Completable
}
@objc open class AFSessionDelegate : ObjectiveC.NSObject {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var sessionDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLAuthenticationChallenge) -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?))?
  open var sessionDidReceiveChallengeWithCompletion: ((Foundation.URLSession, Foundation.URLAuthenticationChallenge, @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void) -> Swift.Void)?
  open var sessionDidFinishEventsForBackgroundURLSession: ((Foundation.URLSession) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Foundation.URLRequest?)?
  open var taskWillPerformHTTPRedirectionWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?))?
  open var taskDidReceiveChallengeWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge, @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Foundation.InputStream?)?
  open var taskNeedNewBodyStreamWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, @escaping (Foundation.InputStream?) -> Swift.Void) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var dataTaskDidReceiveResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLResponse) -> Foundation.URLSession.ResponseDisposition)?
  open var dataTaskDidReceiveResponseWithCompletion: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLResponse, @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void) -> Swift.Void)?
  open var dataTaskDidBecomeDownloadTask: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLSessionDownloadTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)?
  open var dataTaskWillCacheResponseWithCompletion: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse, @escaping (Foundation.CachedURLResponse?) -> Swift.Void) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  open var streamTaskReadClosed: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  open var streamTaskWriteClosed: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  open var streamTaskBetterRouteDiscovered: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  open var streamTaskDidBecomeInputAndOutputStreams: ((Foundation.URLSession, Foundation.URLSessionStreamTask, Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? {
    get
    set
  }
  open subscript(task: Foundation.URLSessionTask) -> IMMap.Request? {
    get
    set
  }
  @objc override dynamic public init()
  @objc override dynamic open func responds(to selector: ObjectiveC.Selector) -> Swift.Bool
  @objc deinit
}
extension AFSessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSessionDidFinishEvents(forBackgroundURLSession session: Foundation.URLSession)
}
extension AFSessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
  @objc(URLSession:task:didFinishCollectingMetrics:) dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
}
extension AFSessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didBecome downloadTask: Foundation.URLSessionDownloadTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension AFSessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
}
@available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
extension AFSessionDelegate : Foundation.URLSessionStreamDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, readClosedFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, writeClosedFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, betterRouteDiscoveredFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, streamTask: Foundation.URLSessionStreamTask, didBecome inputStream: Foundation.InputStream, outputStream: Foundation.OutputStream)
}
extension ObservableType {
  public func window(timeSpan: IMMap.RxTimeInterval, count: Swift.Int, scheduler: IMMap.SchedulerType) -> IMMap.Observable<IMMap.Observable<Self.Element>>
}
public protocol StoryboardSegueIdentifierType : IMMap.IdentifierType {
  associatedtype SegueType
  associatedtype SourceType
  associatedtype DestinationType
}
public struct StoryboardSegueIdentifier<Segue, Source, Destination> : IMMap.StoryboardSegueIdentifierType {
  public typealias SegueType = Segue
  public typealias SourceType = Source
  public typealias DestinationType = Destination
  public let identifier: Swift.String
  public init(identifier: Swift.String)
  public func storyboardSegue(withSource source: Source) -> IMMap.StoryboardSegue<Segue, Source, Destination>
}
public struct TypedStoryboardSegueInfo<Segue, Source, Destination> : IMMap.StoryboardSegueIdentifierType {
  public typealias SegueType = Segue
  public typealias SourceType = Source
  public typealias DestinationType = Destination
  public let destination: Destination
  public let identifier: Swift.String
  public let segue: Segue
  public let source: Source
}
public struct StoryboardSegue<Segue, Source, Destination> {
  public let identifier: IMMap.StoryboardSegueIdentifier<Segue, Source, Destination>
  public let source: Source
  public init(identifier: IMMap.StoryboardSegueIdentifier<Segue, Source, Destination>, source: Source)
}
public typealias PrefetcherProgressBlock = (([IMMap.Resource], [IMMap.Resource], [IMMap.Resource]) -> Swift.Void)
public typealias PrefetcherSourceProgressBlock = (([IMMap.Source], [IMMap.Source], [IMMap.Source]) -> Swift.Void)
public typealias PrefetcherCompletionHandler = (([IMMap.Resource], [IMMap.Resource], [IMMap.Resource]) -> Swift.Void)
public typealias PrefetcherSourceCompletionHandler = (([IMMap.Source], [IMMap.Source], [IMMap.Source]) -> Swift.Void)
public class ImagePrefetcher : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var maxConcurrentDownloads: Swift.Int
  convenience public init(urls: [Foundation.URL], options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.PrefetcherProgressBlock? = nil, completionHandler: IMMap.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [IMMap.Resource], options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.PrefetcherProgressBlock? = nil, completionHandler: IMMap.PrefetcherCompletionHandler? = nil)
  convenience public init(sources: [IMMap.Source], options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.PrefetcherSourceProgressBlock? = nil, completionHandler: IMMap.PrefetcherSourceCompletionHandler? = nil)
  public func start()
  public func stop()
  @objc deinit
}
public typealias Transformer = (CoreImage.CIImage) -> CoreImage.CIImage?
public protocol CIImageProcessor : IMMap.ImageProcessor {
  var filter: IMMap.KFFilter { get }
}
extension CIImageProcessor {
  public func process(item: IMMap.ImageProcessItem, options: IMMap.KingfisherParsedOptionsInfo) -> IMMap.KFCrossPlatformImage?
}
public struct KFFilter {
  public init(transform: @escaping IMMap.Transformer)
  public static var tint: (IMMap.KFCrossPlatformColor) -> IMMap.KFFilter
  public typealias ColorElement = (CoreGraphics.CGFloat, CoreGraphics.CGFloat, CoreGraphics.CGFloat, CoreGraphics.CGFloat)
  public static var colorControl: (IMMap.KFFilter.ColorElement) -> IMMap.KFFilter
}
extension KingfisherWrapper where Base : IMMap.KFCrossPlatformImage {
  public func apply(_ filter: IMMap.KFFilter) -> IMMap.KFCrossPlatformImage
}
extension ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func range(start: Self.Element, count: Self.Element, scheduler: IMMap.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> IMMap.Observable<Self.Element>
}
public typealias DownloadProgressBlock = ((Swift.Int64, Swift.Int64) -> Swift.Void)
public struct RetrieveImageResult {
  public let image: IMMap.KFCrossPlatformImage
  public let cacheType: IMMap.CacheType
  public let source: IMMap.Source
  public let originalSource: IMMap.Source
}
public struct PropagationError {
  public let source: IMMap.Source
  public let error: IMMap.KingfisherError
}
public typealias DownloadTaskUpdatedBlock = ((IMMap.DownloadTask?) -> Swift.Void)
public class KingfisherManager {
  public static let shared: IMMap.KingfisherManager
  public var cache: IMMap.ImageCache
  public var downloader: IMMap.ImageDownloader
  public var defaultOptions: IMMap.KingfisherOptionsInfo
  public init(downloader: IMMap.ImageDownloader, cache: IMMap.ImageCache)
  @discardableResult
  public func retrieveImage(with resource: IMMap.Resource, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, downloadTaskUpdated: IMMap.DownloadTaskUpdatedBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)?) -> IMMap.DownloadTask?
  public func retrieveImage(with source: IMMap.Source, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, downloadTaskUpdated: IMMap.DownloadTaskUpdatedBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)?) -> IMMap.DownloadTask?
  @objc deinit
}
@objc final public class EKRatingSymbolsContainerView : UIKit.UIView {
  final public func setup(with message: IMMap.EKRatingMessage, externalSelection: @escaping IMMap.EKRatingMessage.Selection)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension ObservableType {
  public func subscribeOn(_ scheduler: IMMap.ImmediateSchedulerType) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func observeOn(_ scheduler: IMMap.ImmediateSchedulerType) -> IMMap.Observable<Self.Element>
}
extension String : IMMap.KingfisherCompatibleValue {
}
@objc public class EKMessageContentView : UIKit.UIView {
  public var titleContent: IMMap.EKProperty.LabelContent! {
    get
    set
  }
  public var subtitleContent: IMMap.EKProperty.LabelContent! {
    get
    set
  }
  public var titleAttributes: IMMap.EKProperty.LabelStyle! {
    get
    set
  }
  public var subtitleAttributes: IMMap.EKProperty.LabelStyle! {
    get
    set
  }
  public var title: Swift.String! {
    get
    set
  }
  public var subtitle: Swift.String! {
    get
    set
  }
  public var verticalMargins: CoreGraphics.CGFloat {
    get
    set
  }
  public var horizontalMargins: CoreGraphics.CGFloat {
    get
    set
  }
  public var labelsOffset: CoreGraphics.CGFloat {
    get
    set
  }
  @objc dynamic public init()
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct EKProperty {
  public struct ButtonContent {
    public typealias Action = () -> ()
    public var label: IMMap.EKProperty.LabelContent
    public var backgroundColor: IMMap.EKColor
    public var highlightedBackgroundColor: IMMap.EKColor
    public var contentEdgeInset: CoreGraphics.CGFloat
    public var displayMode: IMMap.EKAttributes.DisplayMode
    public var accessibilityIdentifier: Swift.String?
    public var action: IMMap.EKProperty.ButtonContent.Action?
    public init(label: IMMap.EKProperty.LabelContent, backgroundColor: IMMap.EKColor, highlightedBackgroundColor: IMMap.EKColor, contentEdgeInset: CoreGraphics.CGFloat = 5, displayMode: IMMap.EKAttributes.DisplayMode = .inferred, accessibilityIdentifier: Swift.String? = nil, action: @escaping IMMap.EKProperty.ButtonContent.Action = {})
    public func backgroundColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
    public func highlightedBackgroundColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
    public func highlighedLabelColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
  }
  public struct LabelContent {
    public var text: Swift.String
    public var style: IMMap.EKProperty.LabelStyle
    public var accessibilityIdentifier: Swift.String?
    public init(text: Swift.String, style: IMMap.EKProperty.LabelStyle, accessibilityIdentifier: Swift.String? = nil)
  }
  public struct LabelStyle {
    public var font: UIKit.UIFont
    public var color: IMMap.EKColor
    public var alignment: UIKit.NSTextAlignment
    public var numberOfLines: Swift.Int
    public var displayMode: IMMap.EKAttributes.DisplayMode
    public init(font: UIKit.UIFont, color: IMMap.EKColor, alignment: UIKit.NSTextAlignment = .left, displayMode: IMMap.EKAttributes.DisplayMode = .inferred, numberOfLines: Swift.Int = 0)
    public func color(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
  }
  public struct ImageContent {
    public enum TransformAnimation {
      case animate(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, transform: CoreGraphics.CGAffineTransform)
      case none
    }
    public var tint: IMMap.EKColor?
    public var images: [UIKit.UIImage]
    public var imageSequenceAnimationDuration: Foundation.TimeInterval
    public var size: CoreGraphics.CGSize?
    public var contentMode: UIKit.UIView.ContentMode
    public var makesRound: Swift.Bool
    public var animation: IMMap.EKProperty.ImageContent.TransformAnimation
    public var displayMode: IMMap.EKAttributes.DisplayMode
    public var accessibilityIdentifier: Swift.String?
    public init(imageName: Swift.String, animation: IMMap.EKProperty.ImageContent.TransformAnimation = .none, displayMode: IMMap.EKAttributes.DisplayMode = .inferred, size: CoreGraphics.CGSize? = nil, contentMode: UIKit.UIView.ContentMode = .scaleToFill, tint: IMMap.EKColor? = nil, makesRound: Swift.Bool = false, accessibilityIdentifier: Swift.String? = nil)
    public init(image: UIKit.UIImage, animation: IMMap.EKProperty.ImageContent.TransformAnimation = .none, displayMode: IMMap.EKAttributes.DisplayMode = .inferred, size: CoreGraphics.CGSize? = nil, tint: IMMap.EKColor? = nil, contentMode: UIKit.UIView.ContentMode = .scaleToFill, makesRound: Swift.Bool = false, accessibilityIdentifier: Swift.String? = nil)
    public init(images: [UIKit.UIImage], imageSequenceAnimationDuration: Foundation.TimeInterval = 1, displayMode: IMMap.EKAttributes.DisplayMode = .inferred, animation: IMMap.EKProperty.ImageContent.TransformAnimation = .none, size: CoreGraphics.CGSize? = nil, tint: IMMap.EKColor? = nil, contentMode: UIKit.UIView.ContentMode = .scaleToFill, makesRound: Swift.Bool = false, accessibilityIdentifier: Swift.String? = nil)
    public init(imagesNames: [Swift.String], imageSequenceAnimationDuration: Foundation.TimeInterval = 1, displayMode: IMMap.EKAttributes.DisplayMode = .inferred, animation: IMMap.EKProperty.ImageContent.TransformAnimation = .none, size: CoreGraphics.CGSize? = nil, tint: IMMap.EKColor? = nil, contentMode: UIKit.UIView.ContentMode = .scaleToFill, makesRound: Swift.Bool = false, accessibilityIdentifier: Swift.String? = nil)
    public static func thumb(with image: UIKit.UIImage, edgeSize: CoreGraphics.CGFloat) -> IMMap.EKProperty.ImageContent
    public static func thumb(with imageName: Swift.String, edgeSize: CoreGraphics.CGFloat) -> IMMap.EKProperty.ImageContent
    public func tintColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor?
  }
  public struct TextFieldContent {
    weak public var delegate: UIKit.UITextFieldDelegate?
    public var keyboardType: UIKit.UIKeyboardType
    public var isSecure: Swift.Bool
    public var leadingImage: UIKit.UIImage!
    public var placeholder: IMMap.EKProperty.LabelContent
    public var textStyle: IMMap.EKProperty.LabelStyle
    public var tintColor: IMMap.EKColor!
    public var displayMode: IMMap.EKAttributes.DisplayMode
    public var bottomBorderColor: IMMap.EKColor
    public var accessibilityIdentifier: Swift.String?
    public var textContent: Swift.String {
      get
      set
    }
    public init(delegate: UIKit.UITextFieldDelegate? = nil, keyboardType: UIKit.UIKeyboardType = .default, placeholder: IMMap.EKProperty.LabelContent, tintColor: IMMap.EKColor? = nil, displayMode: IMMap.EKAttributes.DisplayMode = .inferred, textStyle: IMMap.EKProperty.LabelStyle, isSecure: Swift.Bool = false, leadingImage: UIKit.UIImage? = nil, bottomBorderColor: IMMap.EKColor = .clear, accessibilityIdentifier: Swift.String? = nil)
    public func tintColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor?
    public func bottomBorderColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor?
  }
  public struct ButtonBarContent {
    public var content: [IMMap.EKProperty.ButtonContent]
    public var separatorColor: IMMap.EKColor
    public var horizontalDistributionThreshold: Swift.Int
    public var expandAnimatedly: Swift.Bool
    public var buttonHeight: CoreGraphics.CGFloat
    public var displayMode: IMMap.EKAttributes.DisplayMode
    public init(with buttonContents: IMMap.EKProperty.ButtonContent..., separatorColor: IMMap.EKColor, horizontalDistributionThreshold: Swift.Int = 2, buttonHeight: CoreGraphics.CGFloat = 50, displayMode: IMMap.EKAttributes.DisplayMode = .inferred, expandAnimatedly: Swift.Bool)
    public init(with buttonContents: [IMMap.EKProperty.ButtonContent], separatorColor: IMMap.EKColor, horizontalDistributionThreshold: Swift.Int = 2, buttonHeight: CoreGraphics.CGFloat = 50, displayMode: IMMap.EKAttributes.DisplayMode = .inferred, expandAnimatedly: Swift.Bool)
    public func separatorColor(for traitCollection: UIKit.UITraitCollection) -> UIKit.UIColor
  }
  public struct EKRatingItemContent {
    public var title: IMMap.EKProperty.LabelContent
    public var description: IMMap.EKProperty.LabelContent
    public var unselectedImage: IMMap.EKProperty.ImageContent
    public var selectedImage: IMMap.EKProperty.ImageContent
    public var size: CoreGraphics.CGSize
    public init(title: IMMap.EKProperty.LabelContent, description: IMMap.EKProperty.LabelContent, unselectedImage: IMMap.EKProperty.ImageContent, selectedImage: IMMap.EKProperty.ImageContent, size: CoreGraphics.CGSize = CGSize(width: 50, height: 50))
  }
}
extension ObservableType {
  public func single() -> IMMap.Observable<Self.Element>
  public func single(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> IMMap.Observable<Self.Element>
}
public enum SharingScheduler {
  public static var make: () -> IMMap.SchedulerType {
    get
    }
  public static func mock(scheduler: IMMap.SchedulerType, action: () -> Swift.Void)
  public static func mock(makeScheduler: @escaping () -> IMMap.SchedulerType, action: () -> Swift.Void)
}
extension Reactive where Base : UIKit.UIDatePicker {
  public var date: IMMap.ControlProperty<Foundation.Date> {
    get
  }
  public var value: IMMap.ControlProperty<Foundation.Date> {
    get
  }
  public var countDownDuration: IMMap.ControlProperty<Foundation.TimeInterval> {
    get
  }
}
extension ObservableType {
  public static func of(_ elements: Self.Element..., scheduler: IMMap.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public static func from(_ array: [Self.Element], scheduler: IMMap.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> IMMap.Observable<Self.Element>
  public static func from<Sequence>(_ sequence: Sequence, scheduler: IMMap.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> IMMap.Observable<Self.Element> where Sequence : Swift.Sequence, Self.Element == Sequence.Element
}
extension PublishRelay {
  final public func asSignal() -> IMMap.Signal<Element>
}
extension Reactive where Base : Foundation.NotificationCenter {
  public func notification(_ name: Foundation.Notification.Name?, object: Swift.AnyObject? = nil) -> IMMap.Observable<Foundation.Notification>
}
extension ObservableType {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> IMMap.Observable<(O1.Element, O2.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType
}
extension ObservableType {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType
}
extension ObservableType {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType
}
extension ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType
}
extension ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType
}
extension ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType, O7 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType, O7 : IMMap.ObservableType
}
extension ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Self.Element) -> IMMap.Observable<Self.Element> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType, O7 : IMMap.ObservableType, O8 : IMMap.ObservableType
}
extension ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> IMMap.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : IMMap.ObservableType, O2 : IMMap.ObservableType, O3 : IMMap.ObservableType, O4 : IMMap.ObservableType, O5 : IMMap.ObservableType, O6 : IMMap.ObservableType, O7 : IMMap.ObservableType, O8 : IMMap.ObservableType
}
extension BehaviorRelay {
  final public func asDriver() -> IMMap.Driver<Element>
}
extension ObservableType {
  public func flatMap<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> IMMap.Observable<Source.Element> where Source : IMMap.ObservableConvertibleType
}
extension ObservableType {
  public func flatMapFirst<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> IMMap.Observable<Source.Element> where Source : IMMap.ObservableConvertibleType
}
extension ObservableType where Self.Element : IMMap.ObservableConvertibleType {
  public func merge() -> IMMap.Observable<Self.Element.Element>
  public func merge(maxConcurrent: Swift.Int) -> IMMap.Observable<Self.Element.Element>
}
extension ObservableType where Self.Element : IMMap.ObservableConvertibleType {
  public func concat() -> IMMap.Observable<Self.Element.Element>
}
extension ObservableType {
  public static func merge<Collection>(_ sources: Collection) -> IMMap.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element == IMMap.Observable<Self.Element>
  public static func merge(_ sources: [IMMap.Observable<Self.Element>]) -> IMMap.Observable<Self.Element>
  public static func merge(_ sources: IMMap.Observable<Self.Element>...) -> IMMap.Observable<Self.Element>
}
extension ObservableType {
  public func concatMap<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> IMMap.Observable<Source.Element> where Source : IMMap.ObservableConvertibleType
}
public typealias ItemMovedEvent = (sourceIndex: Foundation.IndexPath, destinationIndex: Foundation.IndexPath)
public typealias WillDisplayCellEvent = (cell: UIKit.UITableViewCell, indexPath: Foundation.IndexPath)
public typealias DidEndDisplayingCellEvent = (cell: UIKit.UITableViewCell, indexPath: Foundation.IndexPath)
extension KingfisherWrapper where Base : UIKit.NSTextAttachment {
  @discardableResult
  public func setImage(with source: IMMap.Source?, attributedView: IMMap.KFCrossPlatformView, placeholder: IMMap.KFCrossPlatformImage? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  @discardableResult
  public func setImage(with resource: IMMap.Resource?, attributedView: IMMap.KFCrossPlatformView, placeholder: IMMap.KFCrossPlatformImage? = nil, options: IMMap.KingfisherOptionsInfo? = nil, progressBlock: IMMap.DownloadProgressBlock? = nil, completionHandler: ((IMMap.KFResult<IMMap.RetrieveImageResult, IMMap.KingfisherError>) -> Swift.Void)? = nil) -> IMMap.DownloadTask?
  public func cancelDownloadTask()
}
extension KingfisherWrapper where Base : UIKit.NSTextAttachment {
  public var taskIdentifier: IMMap.Source.Identifier.Value? {
    get
  }
}
@objc final public class EKFormMessageView : UIKit.UIView {
  public init(with title: IMMap.EKProperty.LabelContent, textFieldsContent: [IMMap.EKProperty.TextFieldContent], buttonContent: IMMap.EKProperty.ButtonContent)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  final public func becomeFirstResponder(with textFieldIndex: Swift.Int)
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
final public class RefCountDisposable : IMMap.DisposeBase, IMMap.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(disposable: IMMap.Disposable)
  final public func retain() -> IMMap.Disposable
  final public func dispose()
  @objc deinit
}
public enum SwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension SwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct JSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  mutating public func merge(with other: IMMap.JSON) throws
  public func merged(with other: IMMap.JSON) throws -> IMMap.JSON
  public var type: IMMap.Type {
    get
    }
  public var error: IMMap.SwiftyJSONError? {
    get
    }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: IMMap.JSON {
    get
  }
  public static var null: IMMap.JSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: IMMap.Index<T>, rhs: IMMap.Index<T>) -> Swift.Bool
  public static func < (lhs: IMMap.Index<T>, rhs: IMMap.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = IMMap.Index<IMMap.JSON>
public typealias JSONRawIndex = IMMap.Index<Any>
extension JSON : Swift.Collection {
  public typealias Index = IMMap.JSONRawIndex
  public var startIndex: IMMap.JSON.Index {
    get
  }
  public var endIndex: IMMap.JSON.Index {
    get
  }
  public func index(after i: IMMap.JSON.Index) -> IMMap.JSON.Index
  public subscript(position: IMMap.JSON.Index) -> (Swift.String, IMMap.JSON) {
    get
  }
  public typealias Element = (Swift.String, IMMap.JSON)
  public typealias Iterator = Swift.IndexingIterator<IMMap.JSON>
  public typealias SubSequence = Swift.Slice<IMMap.JSON>
  public typealias Indices = Swift.DefaultIndices<IMMap.JSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: IMMap.JSONKey { get }
}
extension Int : IMMap.JSONSubscriptType {
  public var jsonKey: IMMap.JSONKey {
    get
  }
}
extension String : IMMap.JSONSubscriptType {
  public var jsonKey: IMMap.JSONKey {
    get
  }
}
extension JSON {
  public subscript(path: [IMMap.JSONSubscriptType]) -> IMMap.JSON {
    get
    set
  }
  public subscript(path: IMMap.JSONSubscriptType...) -> IMMap.JSON {
    get
    set
  }
}
extension JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension JSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [IMMap.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension JSON {
  public var array: [IMMap.JSON]? {
    get
  }
  public var arrayValue: [IMMap.JSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension JSON {
  public var dictionary: [Swift.String : IMMap.JSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : IMMap.JSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension JSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension JSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension JSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension JSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension JSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension JSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension JSON : Swift.Comparable {
}
public func == (lhs: IMMap.JSON, rhs: IMMap.JSON) -> Swift.Bool
public func <= (lhs: IMMap.JSON, rhs: IMMap.JSON) -> Swift.Bool
public func >= (lhs: IMMap.JSON, rhs: IMMap.JSON) -> Swift.Bool
public func > (lhs: IMMap.JSON, rhs: IMMap.JSON) -> Swift.Bool
public func < (lhs: IMMap.JSON, rhs: IMMap.JSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: IMMap.writingOptionsKeys, b: IMMap.writingOptionsKeys) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension JSON : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension ControlEvent {
  public func asDriver() -> IMMap.Driver<IMMap.ControlEvent<PropertyType>.Element>
}
extension UIStoryboard {
  convenience public init(resource: IMMap.StoryboardResourceType)
}
public struct AVAssetImageDataProvider : IMMap.ImageDataProvider {
  public enum AVAssetImageDataProviderError : Swift.Error {
    case userCancelled
    case invalidImage(_: CoreGraphics.CGImage?)
  }
  public let assetImageGenerator: AVFoundation.AVAssetImageGenerator
  public let time: CoreMedia.CMTime
  public var cacheKey: Swift.String {
    get
  }
  public init(assetImageGenerator: AVFoundation.AVAssetImageGenerator, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, seconds: Foundation.TimeInterval)
  public func data(handler: @escaping (IMMap.KFResult<Foundation.Data, Swift.Error>) -> Swift.Void)
}
extension Reactive where Base : UIKit.UISlider {
  public var value: IMMap.ControlProperty<Swift.Float> {
    get
  }
}
@objc final public class EKPopUpMessageView : UIKit.UIView {
  public init(with message: IMMap.EKPopUpMessage)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension Reactive where Base : UIKit.UITabBar {
  public var willBeginCustomizing: IMMap.ControlEvent<[UIKit.UITabBarItem]> {
    get
  }
  public var didBeginCustomizing: IMMap.ControlEvent<[UIKit.UITabBarItem]> {
    get
  }
  public var willEndCustomizing: IMMap.ControlEvent<([UIKit.UITabBarItem], Swift.Bool)> {
    get
  }
  public var didEndCustomizing: IMMap.ControlEvent<([UIKit.UITabBarItem], Swift.Bool)> {
    get
  }
}
extension Reactive where Base : UIKit.UITabBar {
  public var delegate: IMMap.DelegateProxy<UIKit.UITabBar, UIKit.UITabBarDelegate> {
    get
  }
  public var didSelectItem: IMMap.ControlEvent<UIKit.UITabBarItem> {
    get
  }
}
public enum RxCocoaError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case invalidOperation(object: Any)
  case itemsNotYetBound(object: Any)
  case invalidPropertyName(object: Any, propertyName: Swift.String)
  case invalidObjectOnKeyPath(object: Any, sourceObject: Swift.AnyObject, propertyName: Swift.String)
  case errorDuringSwizzling
  case castingError(object: Any, targetType: Any.Type)
}
extension RxCocoaError {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ImageProgressive {
  public static let `default`: IMMap.ImageProgressive
  public init(isBlur: Swift.Bool, isFastestScan: Swift.Bool, scanInterval: Foundation.TimeInterval)
}
public class DisposeBase {
  @objc deinit
}
extension UICollectionView {
  public func dequeueReusableCell<Identifier>(withReuseIdentifier identifier: Identifier, for indexPath: Foundation.IndexPath) -> Identifier.ReusableType? where Identifier : IMMap.ReuseIdentifierType, Identifier.ReusableType : UIKit.UICollectionReusableView
  public func dequeueReusableSupplementaryView<Identifier>(ofKind elementKind: Swift.String, withReuseIdentifier identifier: Identifier, for indexPath: Foundation.IndexPath) -> Identifier.ReusableType? where Identifier : IMMap.ReuseIdentifierType, Identifier.ReusableType : UIKit.UICollectionReusableView
  public func register<Resource>(_ nibResource: Resource) where Resource : IMMap.NibResourceType, Resource : IMMap.ReuseIdentifierType, Resource.ReusableType : UIKit.UICollectionViewCell
  public func register<Resource>(_ nibResource: Resource, forSupplementaryViewOfKind kind: Swift.String) where Resource : IMMap.NibResourceType, Resource : IMMap.ReuseIdentifierType, Resource.ReusableType : UIKit.UICollectionReusableView
}
public protocol DelegateProxyType : AnyObject {
  associatedtype ParentObject : AnyObject
  associatedtype Delegate
  static func registerKnownImplementations()
  static var identifier: Swift.UnsafeRawPointer { get }
  static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
  func forwardToDelegate() -> Self.Delegate?
  func setForwardToDelegate(_ forwardToDelegate: Self.Delegate?, retainDelegate: Swift.Bool)
}
extension DelegateProxyType {
  public static var identifier: Swift.UnsafeRawPointer {
    get
  }
}
extension DelegateProxyType {
  public static func register<Parent>(make: @escaping (Parent) -> Self)
  public static func createProxy(for object: Swift.AnyObject) -> Self
  public static func proxy(for object: Self.ParentObject) -> Self
  public static func installForwardDelegate(_ forwardDelegate: Self.Delegate, retainDelegate: Swift.Bool, onProxyForObject object: Self.ParentObject) -> IMMap.Disposable
}
public protocol HasDelegate : AnyObject {
  associatedtype Delegate
  var delegate: Self.Delegate? { get set }
}
extension DelegateProxyType where Self.Delegate == Self.ParentObject.Delegate, Self.ParentObject : IMMap.HasDelegate {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
public protocol HasDataSource : AnyObject {
  associatedtype DataSource
  var dataSource: Self.DataSource? { get set }
}
extension DelegateProxyType where Self.Delegate == Self.ParentObject.DataSource, Self.ParentObject : IMMap.HasDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
@available(iOS 10.0, tvOS 10.0, *)
public protocol HasPrefetchDataSource : AnyObject {
  associatedtype PrefetchDataSource
  var prefetchDataSource: Self.PrefetchDataSource? { get set }
}
@available(iOS 10.0, tvOS 10.0, *)
extension DelegateProxyType where Self.Delegate == Self.ParentObject.PrefetchDataSource, Self.ParentObject : IMMap.HasPrefetchDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
extension Reactive where Base : UIKit.UIApplication {
  public var isNetworkActivityIndicatorVisible: IMMap.Binder<Swift.Bool> {
    get
  }
}
public struct TextInput<Base> where Base : UIKit.UITextInput {
  public let base: Base
  public let text: IMMap.ControlProperty<Swift.String?>
  public init(base: Base, text: IMMap.ControlProperty<Swift.String?>)
}
extension Reactive where Base : UIKit.UITextField {
  public var textInput: IMMap.TextInput<Base> {
    get
  }
}
extension Reactive where Base : UIKit.UITextView {
  public var textInput: IMMap.TextInput<Base> {
    get
  }
}
extension IMMap.EKAttributes.NotificationHapticFeedback : Swift.Equatable {}
extension IMMap.EKAttributes.NotificationHapticFeedback : Swift.Hashable {}
extension IMMap.VirtualTimeComparison : Swift.Equatable {}
extension IMMap.VirtualTimeComparison : Swift.Hashable {}
extension IMMap.EKAttributes.Precedence.QueueingHeuristic : Swift.Equatable {}
extension IMMap.EKAttributes.Precedence.QueueingHeuristic : Swift.Hashable {}
extension IMMap.EKAttributes.DisplayMode : Swift.Equatable {}
extension IMMap.EKAttributes.DisplayMode : Swift.Hashable {}
extension IMMap.EKAttributes.Animation.Translate.AnchorPosition : Swift.Hashable {}
extension IMMap.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation : Swift.Equatable {}
extension IMMap.EKAttributes.PositionConstraints.Rotation.SupportedInterfaceOrientation : Swift.Hashable {}
extension IMMap.ImageFormat : Swift.Hashable {}
extension IMMap.HTTPMethod : Swift.Equatable {}
extension IMMap.HTTPMethod : Swift.Hashable {}
extension IMMap.HTTPMethod : Swift.RawRepresentable {}
extension IMMap.URLEncoding.Destination : Swift.Equatable {}
extension IMMap.URLEncoding.Destination : Swift.Hashable {}
extension IMMap.URLEncoding.ArrayEncoding : Swift.Equatable {}
extension IMMap.URLEncoding.ArrayEncoding : Swift.Hashable {}
extension IMMap.URLEncoding.BoolEncoding : Swift.Equatable {}
extension IMMap.URLEncoding.BoolEncoding : Swift.Hashable {}
extension IMMap.EKAttributes.StatusBar : Swift.Equatable {}
extension IMMap.EKAttributes.StatusBar : Swift.Hashable {}
extension IMMap.EKAttributes.Position : Swift.Equatable {}
extension IMMap.EKAttributes.Position : Swift.Hashable {}
extension IMMap.SubjectLifetimeScope : Swift.Equatable {}
extension IMMap.SubjectLifetimeScope : Swift.Hashable {}
extension IMMap.CacheType : Swift.Hashable {}
extension IMMap.RxCocoaInterceptionMechanism : Swift.Equatable {}
extension IMMap.RxCocoaInterceptionMechanism : Swift.Hashable {}
extension IMMap.EKAlertMessage.ImagePosition : Swift.Equatable {}
extension IMMap.EKAlertMessage.ImagePosition : Swift.Hashable {}
extension IMMap.TakeUntilBehavior : Swift.Equatable {}
extension IMMap.TakeUntilBehavior : Swift.Hashable {}
extension IMMap.ContentMode : Swift.Equatable {}
extension IMMap.ContentMode : Swift.Hashable {}
extension IMMap.QLAxis : Swift.Hashable {}
extension IMMap.NetworkReachabilityManager.ConnectionType : Swift.Equatable {}
extension IMMap.NetworkReachabilityManager.ConnectionType : Swift.Hashable {}
extension IMMap.SwiftyJSONError : Swift.Equatable {}
extension IMMap.SwiftyJSONError : Swift.Hashable {}
extension IMMap.SwiftyJSONError : Swift.RawRepresentable {}
extension IMMap.Type : Swift.Equatable {}
extension IMMap.Type : Swift.Hashable {}
extension IMMap.Type : Swift.RawRepresentable {}
extension IMMap.writingOptionsKeys : Swift.Equatable {}
extension IMMap.writingOptionsKeys : Swift.Hashable {}
